---
title: 《Refactoring》读书笔记（二）重新组织函数
categories:
  - 读书笔记
date: 2018-11-28 13:34:38
tags: Books
---

# 第六章 重新组织函数

## 6.1 Extract Method（提炼函数）

### 概要

你有一段代码可以被组织在一起并独立出来。

**将这段代码放进一个独立函数中，并让函数名称解释该函数的用途。**

### 动机

复用机会大，覆写更容易，使高层函数读起来就像一系列注释。

函数长度不是问题，关键在于函数名称和函数本体之间的语义距离。如果提炼可以强化代码的清晰度，那就去做，就算函数名称比提炼出来的代码还长也无所谓。

难点在于局部变量，包括传进源函数的参数和源函数所声明的临时变量。

可以先尝试运用 Replace Temp with Query（120）减少临时变量。如果仍困难重重，我就会动用 Replace Method with Method Object（135），这个重构手法不在乎代码中有多少临时变量，也不在乎你如何使用它们。

<!-- more -->

## 6.2 Inline Method（内联函数）

### 概要

一个函数的本体与名称同样清楚易懂。

**在函数调用点插入函数本体，然后移除该函数。**

### 动机

间接层有其价值，但不是所有间接层都有价值。

另一种需要使用 Inline Method（117）的情况是，你手上有一群组织不甚合理的函数。你可以将它们都内联到一个大型函数中，再从中提炼出组织合理的小型函数。Kent Beck 发现，实施 Replace Method with Method Object（135）之前先这么做， 往往可以获得不错的效果。

### 做法

- 检查函数，确定它不具多态性（如果子类继承了这个函数，就不要将此函数内联，因为子类无法覆写一个根本不存在的函数。）
- 略

难点：对于递归调用、多返回点、内联至另一个对象中而该对象并无提供访问函数……等等。如果遇到了这样的复杂情况，那么就不应该使用这个重构手法。

## 6.3 Inline Temp（内联临时变量）

### 概要

你有一个临时变量，只被一个简单表达式赋值一次，而它妨碍了其它重构手法。

**将所有对该变量的引用动作，替换为对它赋值的那个表达式本身。**

### 动机

Inline Temp（119）多半是作为 Replace Temp with Query（120）的一部分使用的，所以真正的动机出现在后者那儿。

## 6.4 Replace Temp with Query

### 概要

你的程序以一个临时变量保存某一表达式的运算结果。

**将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可以被其它函数使用。**

### 动机

由于临时变量只在所属函数内可见，所以它们会**驱使你写出更长的函数，因为只有这样你才能访问到需要的临时变量。**

## 6.5 Introduce Explaining Variable（引入解释性变量）

### 概要

你有一个复杂的表达式。

**将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。**

## 6.6 Split Temporary Varibale（分解临时变量）

### 概要

你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。

**针对每次赋值，创造一个独立、对应的临时变量。**

### 动机

同一个临时变量承担两件不同的事情，会令代码阅读者糊涂。

> 我敢保证，这比吃苏格兰布丁强多了——你知道他们都在里面放了些什么东西吗？
>
> （苏格兰布丁：haggis，一种苏格兰菜，把羊心等内脏装在羊胃里煮成。由于它被羊胃包成一个球体，因此可以像球一样踢来踢去。）

## 6.7 Rmove Assignments to Prarmeters（移除对参数的赋值）

### 概要

代码对一个参数进行赋值。

**以一个临时变量取代该参数的位置。**

## 6.8 Replace Method with Method Object（以函数对象取代函数）

### 概要

你有一个大型函数，其中对局部变量的使用使你无法采用 Extract Method（110）。

**将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。**

## 6.9 Substitute Algorithm（替换算法）

### 概要

你想要把某个算法替换为另一个更清晰的算法。

**将函数本体替换为另一个算法。**
