<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css?v=1.0.2">















  
  
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">







<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-medium.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-small.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Runtime本文基于 runtime 的最新版本 750，源码可以点这里下载，可编译版本可以点这里下载。">
<meta name="keywords" content="Runtime">
<meta property="og:type" content="article">
<meta property="og:title" content="Runtime 温故而知新">
<meta property="og:url" content="https://iCodeWoods.github.io/2019/05/16/Runtime 温故而知新/index.html">
<meta property="og:site_name" content="iCodeWoods的小站">
<meta property="og:description" content="Runtime本文基于 runtime 的最新版本 750，源码可以点这里下载，可编译版本可以点这里下载。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://icodewoods.github.io/2019/05/16/Runtime%20温故而知新/Runtime_Breakpoint_Load.png">
<meta property="og:image" content="https://icodewoods.github.io/2019/05/16/Runtime%20温故而知新/Runtime_Product_Exec.png">
<meta property="og:image" content="https://icodewoods.github.io/2019/05/16/Runtime%20温故而知新/Runtime_MachOView_NonLazyClass.png">
<meta property="og:image" content="https://icodewoods.github.io/2019/05/16/Runtime%20温故而知新/Runtime_Hopper_XXObject.png">
<meta property="og:image" content="https://icodewoods.github.io/2019/05/16/Runtime%20温故而知新/Runtime_Breakpoint_LoadImages.png">
<meta property="og:image" content="https://icodewoods.github.io/2019/05/16/Runtime%20温故而知新/Runtime_PrintOption_PrintImageTimes.png">
<meta property="og:image" content="https://icodewoods.github.io/2019/05/16/Runtime%20温故而知新/Runtime_Process.png">
<meta property="og:updated_time" content="2019-10-09T02:24:18.616Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Runtime 温故而知新">
<meta name="twitter:description" content="Runtime本文基于 runtime 的最新版本 750，源码可以点这里下载，可编译版本可以点这里下载。">
<meta name="twitter:image" content="https://icodewoods.github.io/2019/05/16/Runtime%20温故而知新/Runtime_Breakpoint_Load.png">





  
  
  <link rel="canonical" href="https://iCodeWoods.github.io/2019/05/16/Runtime 温故而知新/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Runtime 温故而知新 | iCodeWoods的小站</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">iCodeWoods的小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">片刻之欢愉，不如须臾之宁静</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iCodeWoods.github.io/2019/05/16/Runtime 温故而知新/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iCodeWoods">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iCodeWoods的小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Runtime 温故而知新

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-16 15:51:00" itemprop="dateCreated datePublished" datetime="2019-05-16T15:51:00+08:00">2019-05-16</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><p>本文基于 runtime 的最新版本 750，源码可以<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">点这里</a>下载，可编译版本可以<a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">点这里</a>下载。</p>
<a id="more"></a>
<h2 id="load"><a href="#load" class="headerlink" title="+ load"></a>+ load</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// main.m</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface XXObject : NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation XXObject</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">	NSLog(@&quot;XXObject load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过断点，我们可以看到如下调用栈：</p>
<p><img src="/2019/05/16/Runtime 温故而知新/Runtime_Breakpoint_Load.png" alt="Runtime_Breakpoint_Load"></p>
<h3 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">recursive_mutex_locker_t</span> lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">mutex_locker_t</span> lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码非常清晰：</p>
<ol>
<li><code>hasLoadMethods</code>：通过 <code>mach_header</code> 判断镜像中是否有 load 方法，如果没有直接返回</li>
<li><code>prepare_load_methods</code>：准备好 load 方法</li>
<li><code>call_load_methods</code>：调用 load 方法</li>
</ol>
<blockquote>
<p>PS：mach_header 是一个结构体，里面记录了镜像的一些信息。headerType 在非 64 位下就是 mach_header，在 64 位下是 mach_header_64</p>
</blockquote>
<p>那么 <code>load_images</code> 方法会加载哪些镜像呢？我们在 <code>hasLoadMethods</code> 处增加一个断点，输出 <code>path</code> 以及是否有 <code>load</code> 方法，截取其中一部分输出如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">load_images... path: <span class="string">"/usr/lib/system/introspection/libdispatch.dylib"</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">load_images... path: <span class="string">"/usr/lib/system/libsystem_trace.dylib"</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">load_images... path: <span class="string">"/usr/lib/system/libxpc.dylib"</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">load_images... path: <span class="string">"/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation"</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">load_images... path: <span class="string">"/System/Library/Frameworks/Security.framework/Versions/A/Security"</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">load_images... path: <span class="string">"/usr/lib/libnetwork.dylib"</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">load_images... path: <span class="string">"/System/Library/Frameworks/CFNetwork.framework/Versions/A/CFNetwork"</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// ...省略</span></span><br></pre></td></tr></table></figure>
<p>下面我们就来一步步分析 load_images 所干的这三件事。</p>
<blockquote>
<p>扩展阅读：Mach-O包含以下几种文件类型</p>
<ul>
<li>Executable：应用的主要二进制</li>
<li>Dylib：动态链接库</li>
<li>Bundle：不能被链接，只能在运行时使用dlopen加载</li>
<li>Image：包含 Executable、Dylib 和 Bundle</li>
<li>Framework：包含Dylib、资源文件和头文件的文件夹</li>
</ul>
</blockquote>
<h4 id="hasLoadMethods"><a href="#hasLoadMethods" class="headerlink" title="hasLoadMethods"></a>hasLoadMethods</h4><p>第一步，如何判断一个镜像中是否有 <code>load</code> 方法？其实就是查找该镜像中是否有“非懒加载的类”（NonlazyClass）或“非懒加载的分类”（NonlazyCategory）。结合这个方法的方法名，就很容易这两个概念了——有 <code>+ load</code> 方法的类/分类就是“非懒加载的”，没有 <code>+ load</code> 方法的类/分类就是懒加载的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm</span></span><br><span class="line"><span class="comment">// Quick scan for +load methods that doesn't take a lock.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasLoadMethods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyClassList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyCategoryList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="getObjc2NonlazyClassList"><a href="#getObjc2NonlazyClassList" class="headerlink" title="_getObjc2NonlazyClassList"></a>_getObjc2NonlazyClassList</h5><p>那么如何获取镜像中的 NonlazyClassList/NonlazyCategoryList 呢？我们跳转到 <code>_getObjc2NonlazyClassList</code> 的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object-file.mm</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETSECT(name, type, sectname)                                   \</span></span><br><span class="line">    <span class="function">type *<span class="title">name</span><span class="params">(<span class="keyword">const</span> headerType *mhdr, <span class="keyword">size_t</span> *outCount)</span> </span>&#123;              \</span><br><span class="line">        <span class="keyword">return</span> getDataSection&lt;type&gt;(mhdr, sectname, nil, outCount);     \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    <span class="function">type *<span class="title">name</span><span class="params">(<span class="keyword">const</span> header_info *hi, <span class="keyword">size_t</span> *outCount)</span> </span>&#123;               \</span><br><span class="line">        <span class="keyword">return</span> getDataSection&lt;type&gt;(hi-&gt;mhdr(), sectname, nil, outCount); \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      function name                 content type     section name</span></span><br><span class="line">GETSECT(_getObjc2SelectorRefs,        SEL,             <span class="string">"__objc_selrefs"</span>); </span><br><span class="line">GETSECT(_getObjc2MessageRefs,         <span class="keyword">message_ref_t</span>,   <span class="string">"__objc_msgrefs"</span>); </span><br><span class="line">GETSECT(_getObjc2ClassRefs,           Class,           <span class="string">"__objc_classrefs"</span>);</span><br><span class="line">GETSECT(_getObjc2SuperRefs,           Class,           <span class="string">"__objc_superrefs"</span>);</span><br><span class="line">GETSECT(_getObjc2ClassList,           <span class="keyword">classref_t</span>,      <span class="string">"__objc_classlist"</span>);</span><br><span class="line">GETSECT(_getObjc2NonlazyClassList,    <span class="keyword">classref_t</span>,      <span class="string">"__objc_nlclslist"</span>);</span><br><span class="line">GETSECT(_getObjc2CategoryList,        <span class="keyword">category_t</span> *,    <span class="string">"__objc_catlist"</span>);</span><br><span class="line">GETSECT(_getObjc2NonlazyCategoryList, <span class="keyword">category_t</span> *,    <span class="string">"__objc_nlcatlist"</span>);</span><br><span class="line">GETSECT(_getObjc2ProtocolList,        <span class="keyword">protocol_t</span> *,    <span class="string">"__objc_protolist"</span>);</span><br><span class="line">GETSECT(_getObjc2ProtocolRefs,        <span class="keyword">protocol_t</span> *,    <span class="string">"__objc_protorefs"</span>);</span><br><span class="line">GETSECT(getLibobjcInitializers,       UnsignedInitializer, <span class="string">"__objc_init_func"</span>);</span><br></pre></td></tr></table></figure>
<p>乍一看有点懵，其实很简单，就是 🍎 工程师为了 <del>偷懒</del> 简洁，定义了一个宏来批量实现方法，好比一个模板。</p>
<p>举个🌰，对于 <code>_getObjc2NonlazyClassList</code> 来说，其实这里是实现了两个方法名一样，但参数不同的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">classref_t</span> *_getObjc2NonlazyClassList(<span class="keyword">const</span> headerType *mhdr, <span class="keyword">size_t</span> *outCount) &#123;</span><br><span class="line">    <span class="keyword">return</span> getDataSection&lt;<span class="keyword">classref_t</span>&gt;(mhdr, <span class="string">"__objc_nlclslist"</span>, nil, outCount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">classref_t</span> *_getObjc2NonlazyClassList(<span class="keyword">const</span> header_info *hi, <span class="keyword">size_t</span> *outCount) &#123;</span><br><span class="line">    <span class="keyword">return</span> getDataSection&lt;<span class="keyword">classref_t</span>&gt;(hi-&gt;mhdr, <span class="string">"__objc_nlclslist"</span>, nil, outCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 其实我第一眼看这段代码的时候，有一个疑问：为什么这里可以定义两个方法名一样、但参数不一样的方法呢？要知道在 OC 里，这样可是会报错的。过了一会我才突然想明白，这是 .mm 文件，C++ 是可以这样干的啊！差点被自己蠢哭😂</p>
</blockquote>
<h5 id="getDataSection"><a href="#getDataSection" class="headerlink" title="getDataSection"></a>getDataSection</h5><p>ok，现在只剩下 <code>getDataSection</code> 这个方法了：通过 headerType，获取镜像的指定 segment 的指定 section 中的数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object-file.mm</span></span><br><span class="line"><span class="comment">// Look for a __DATA or __DATA_CONST or __DATA_DIRTY section </span></span><br><span class="line"><span class="comment">// with the given name that stores an array of T.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T* <span class="title">getDataSection</span><span class="params">(<span class="keyword">const</span> headerType *mhdr, <span class="keyword">const</span> <span class="keyword">char</span> *sectname, </span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">size_t</span> *outBytes, <span class="keyword">size_t</span> *outCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> byteCount = <span class="number">0</span>;</span><br><span class="line">    T* data = (T*)getsectiondata(mhdr, <span class="string">"__DATA"</span>, sectname, &amp;byteCount);</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        data = (T*)getsectiondata(mhdr, <span class="string">"__DATA_CONST"</span>, sectname, &amp;byteCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        data = (T*)getsectiondata(mhdr, <span class="string">"__DATA_DIRTY"</span>, sectname, &amp;byteCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (outBytes) *outBytes = byteCount;</span><br><span class="line">    <span class="keyword">if</span> (outCount) *outCount = byteCount / <span class="keyword">sizeof</span>(T);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是以 <code>_getObjc2NonlazyClassList</code> 为🌰，会先查找 <code>__DATA</code> 段中的 <code>__objc_nlclslist</code> 区块，如果找不到再找 <code>__DATA_CONST</code> 段中的 <code>__objc_nlclslist</code> 区块，以此类推。如果都找不到的话，就说明这个镜像中没有 <code>NonlazyClass</code>，也就是没有 <code>+ load</code> 方法。</p>
<p>为了验证，我们可以在 demo 工程的 Products 目录下，找到工程的编译产物——一个可执行文件（debug-objc）</p>
<p><img src="/2019/05/16/Runtime 温故而知新/Runtime_Product_Exec.png" alt="Runtime_Product_Exec"></p>
<p>然后我们将其拖入 <a href="https://sourceforge.net/projects/machoview/" target="_blank" rel="noopener">MachOView</a> 中查看，在 <code>__DATA</code> 段的 <code>__objc_nlclslist</code> section 中确实只有一个元素，其地址为 <code>0000000100001138</code>（因为此处是大端序，我们将其转化为小端序）</p>
<p><img src="/2019/05/16/Runtime 温故而知新/Runtime_MachOView_NonLazyClass.png" alt="Runtime_MachOView_NonLazyClass"></p>
<p>然后我们将可执行文件拖入 <a href="https://www.hopperapp.com/" target="_blank" rel="noopener">Hopper</a>，找到 <code>0000000100001138</code> 地址上的数据，确实是我们所写的 <code>XXObject</code>：</p>
<p><img src="/2019/05/16/Runtime 温故而知新/Runtime_Hopper_XXObject.png" alt="Runtime_Hopper_XXObject"></p>
<h4 id="prepare-load-methods"><a href="#prepare-load-methods" class="headerlink" title="prepare_load_methods"></a>prepare_load_methods</h4><p>这个函数的作用就是提前将需要调用 <code>load</code> 方法的类和分类分别加入对应的列表中，以供接下来的调用（后面会详述）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">classref_t</span> *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">category_t</span> **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先看类的部分（为了方便快速理解大致逻辑、避免混乱，我们先暂时忽略 <code>remapClass</code>，后面会详述）。</p>
<h5 id="schedule-class-load"><a href="#schedule-class-load" class="headerlink" title="schedule_class_load"></a>schedule_class_load</h5><p><code>_getObjc2NonlazyClassList</code> 上文我们已经解释过了。获取当前镜像的所有非懒加载的类，然后进行遍历，调用 <code>schedule_class_load</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>通过 <code>RW_LOADED</code> 标志位判断类是否已经加载过，如果已经加载过则直接返回，保证<strong>每个类只会加载一次</strong></li>
<li>递归调用 <code>schedule_class_load</code> 对父类进行处理，保证<strong>父类在子类之前</strong>（这里只是”prepare”，不是调用，不过真正调用的时候父类也一定是在子类之前的，后面会详述）</li>
<li>将类和类的 load 方法保存至一个全局列表（<code>loadable_classes</code>）中</li>
<li>将类的 <code>RW_LOADED</code> 标志位置为 1</li>
</ol>
<p>#####add_class_to_loadable_list</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-loadmethod.mm</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"LOAD: class '%s' scheduled for +load"</span>, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            <span class="built_in">realloc</span>(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里通过 <code>loadable_classes_used</code> 记录其个数，<code>loadable_classes</code> 列表的大小是动态创建的，当列表长度不够用时会重新申请内存。（我想这就是为什么如果程序中 <code>+ load</code> 方法太多时，会影响启动性能的原因之一吧。当然影响因素很多，后面我们还会详述）</p>
<blockquote>
<p>上面的方法中，🍎 工程师还非常 <del>逗比</del> 有趣的加了一句注释：“如果类没有load方法，请不要打扰”。😂</p>
</blockquote>
<h5 id="add-category-to-loadable-list"><a href="#add-category-to-loadable-list" class="headerlink" title="add_category_to_loadable_list"></a>add_category_to_loadable_list</h5><p>分类的处理和类的处理差不多：将分类和分类的 load 方法保存至另一个全局列表 <code>loadable_categories</code> 中，通过 <code>loadable_categories_used</code> 记录其个数。我们就不再赘述了。</p>
<h5 id="remapClass"><a href="#remapClass" class="headerlink" title="remapClass"></a>remapClass</h5><p>上面我们说为了防止混乱而暂时忽略了一个方法 <code>remapClass</code>。其实通过 <code>_getObjc2NonlazyClassList</code> 获取的是 <code>classref_t</code>，通过注释我们可以看到它其实是一个“未映射”的 Class：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// classref_t is unremapped class_t*</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">classref</span> * <span class="title">classref_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>而 <code>remapClass</code> 的作用就是将 <code>classref_t</code> 进行重映射，拿到其所对应的 Class：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">remapClass</span><span class="params">(<span class="keyword">classref_t</span> cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remapClass((Class)cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">remapClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    Class c2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    NXMapTable *<span class="built_in">map</span> = remappedClasses(NO);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">map</span>  ||  NXMapMember(<span class="built_in">map</span>, cls, (<span class="keyword">void</span>**)&amp;c2) == NX_MAPNOTAKEY) &#123;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从镜像中获取到的未映射的 <code>classref_t</code> 与其所对应的真正的 Class 是作为一对 key-value 存储在一个映射表里的，其中 <code>classref_t</code> 是 key，对应的 Class 是 value。</p>
<p>不过看到这我们还是不知道，这个映射表是哪来的？后面我们会详述。</p>
<p>下面我们就进入第三步：<code>call_load_methods</code></p>
<h4 id="call-load-methods"><a href="#call-load-methods" class="headerlink" title="call_load_methods"></a>call_load_methods</h4><p>do while 中会先调用 <code>call_class_loads</code>，再调用 call_category_loads，这就保证了<strong>类的 <code>+ load</code> 会在分类之前调用</strong>。（还记得 <code>loadable_classes_used</code> 吗，我们上文提过哦。）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>网上有些博客说，我们重载 <code>+ load</code> 方法时需要手动添加 @autoreleasepool，甚至包括<a href="https://www.mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.html" target="_blank" rel="noopener">Mike Ash 的博客</a>也是这么说的。</p>
<p>但从这段源码我们可以看到，在 <code>runtime</code> 调用<code>+ load</code> 方法的前后已经加了 <code>objc_autoreleasePoolPush()</code> 和 <code>objc_autoreleasePoolPop()</code>，所以我们不需要再手动添加了。大抵是因为他们所写的博客太老了，之后🍎做了更新吧。</p>
<h5 id="call-class-loads"><a href="#call-class-loads" class="headerlink" title="call_class_loads"></a>call_class_loads</h5><p><code>call_class_loads</code> 就是将我们上文所说的 <code>loadable_classes</code> 列表中的类一个一个拿出来，然后调用其 <code>+ load</code> 方法。因为之前写入 <code>loadable_classes</code> 列表时，是先写入的父类，后写入的子类，所以这里<strong>父类的 load 会先于子类调用</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> *<span class="title">classes</span> = <span class="title">loadable_classes</span>;</span></span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) <span class="built_in">free</span>(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心在于这一句，通过函数指针的方式执行 <code>classes[i].method</code>——也就是 <code>+ load</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*load_method)(cls, SEL_load);</span><br></pre></td></tr></table></figure>
<p>这样的调用方式就使得 <code>+ load</code> 有了一个非常有趣的特性。我们知道，通常情况下我们给一个对象发送消息，其实是调用了 <code>objc_msgSend</code> 方法，如果对象不能响应消息，会递归地查找其父类/元类并调用。</p>
<p>而此处 <code>+ load</code> 方法直接使用了函数地址进行调用，并不是通过 <code>objc_msgSend</code>，所以<strong>如果子类没有实现 <code>+ load</code> 方法，那么 runtime 不会调用父类的 <code>+ load</code>。如果类和分类都实现了 <code>+ load</code> 方法，两个方法都会被调用</strong>。</p>
<p>到这里 <code>load_images</code> 的整个流程就讲完了，不过如果你跟我一样好奇的话，查看 <code>SEL_load</code> 时会发现——它竟然是个 <code>NULL</code>！！！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// objc-runtime.mm</span><br><span class="line">// Selectors</span><br><span class="line">SEL SEL_load = NULL;</span><br><span class="line">SEL SEL_initialize = NULL;</span><br><span class="line">SEL SEL_resolveInstanceMethod = NULL;</span><br><span class="line">SEL SEL_resolveClassMethod = NULL;</span><br><span class="line">SEL SEL_cxx_construct = NULL;</span><br><span class="line">SEL SEL_cxx_destruct = NULL;</span><br><span class="line">SEL SEL_retain = NULL;</span><br><span class="line">SEL SEL_release = NULL;</span><br><span class="line">SEL SEL_autorelease = NULL;</span><br><span class="line">SEL SEL_retainCount = NULL;</span><br><span class="line">SEL SEL_alloc = NULL;</span><br><span class="line">SEL SEL_allocWithZone = NULL;</span><br><span class="line">SEL SEL_dealloc = NULL;</span><br><span class="line">SEL SEL_copy = NULL;</span><br><span class="line">SEL SEL_new = NULL;</span><br><span class="line">SEL SEL_forwardInvocation = NULL;</span><br><span class="line">SEL SEL_tryRetain = NULL;</span><br><span class="line">SEL SEL_isDeallocating = NULL;</span><br><span class="line">SEL SEL_retainWeakReference = NULL;</span><br><span class="line">SEL SEL_allowsWeakReference = NULL;</span><br></pre></td></tr></table></figure>
<p>至于为什么会这样，我们后面会详述。</p>
<h4 id="Producer-Consumer"><a href="#Producer-Consumer" class="headerlink" title="Producer-Consumer"></a>Producer-Consumer</h4><p>细心的读者可能已经发现了，<code>load_images</code> 里其实蕴含着一个经典的生产者-消费者问题：</p>
<ul>
<li><code>prepare_load_methods</code> 负责“生产”：从镜像中获取实现了 <code>+ load</code> 方法的类/分类，将类/分类及其 load 方法写入 <code>loadable_classes</code>/<code>loadable_categories</code> 列表中；</li>
<li><code>call_load_methods</code> 负责“消费”：循环地从 <code>loadable_classes</code>/<code>loadable_categories</code> 列表中读取类/分类，执行其 <code>+ load</code> 方法</li>
</ul>
<h5 id="loadMethodLock"><a href="#loadMethodLock" class="headerlink" title="loadMethodLock"></a>loadMethodLock</h5><p>当然，🍎 已经加好了锁。因为类和分类的流程大同小异，所以我们以类为🌰：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `prepare_load_methods` 负责“生产”</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `call_load_methods` 负责“消费”</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    call_class_loads</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> *<span class="title">classes</span> = <span class="title">loadable_classes</span>;</span></span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    (*load_method)(cls, SEL_load);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (classes) <span class="built_in">free</span>(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="objc-init"><a href="#objc-init" class="headerlink" title="_objc_init"></a>_objc_init</h2><p>还记得我们之前遗留的问题吗？remapClass 中的那个映射表是哪来的？<code>SEL_load</code> 等选择子为什么是 NULL？</p>
<p>之所以会遇到这些问题，其实是因为我们前面有些“急于求成”，从 <code>load</code> 方法处的断点定位到 <code>load_images</code> 后就直接一头扎了进去，而没有想想——<code>load_images</code> 是谁调用的？在 <code>load_images</code> 之前发生了什么？</p>
<p>我们在 <code>load_images</code> 处添加一个断点，通过调用栈可以看到另一个方法：<code>_objc_init</code></p>
<p><img src="/2019/05/16/Runtime 温故而知新/Runtime_Breakpoint_LoadImages.png" alt="Runtime_Breakpoint_LoadImages"></p>
<p>其源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-os.mm</span></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _objc_init</span></span><br><span class="line"><span class="comment">* Bootstrap initialization. Registers our image notifier with dyld.</span></span><br><span class="line"><span class="comment">* Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里做了很多初始化的工作，并通过一个静态的布尔型变量保证该方法只会走一次。我们的关注点在于最后一行，这里出现了我们前面花了大量篇幅所讲的 <code>load_images</code>，那么这一整行代码是什么意思呢？</p>
<h3 id="dyld-objc-notify-register"><a href="#dyld-objc-notify-register" class="headerlink" title="_dyld_objc_notify_register"></a>_dyld_objc_notify_register</h3><p>我们跳转到 <code>_dyld_objc_notify_register</code> 的定义，这里已经踏入 dyld 的领地了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dyld_priv.h</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*_dyld_objc_notify_mapped)</span><span class="params">(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> paths[], <span class="keyword">const</span> struct mach_header* <span class="keyword">const</span> mh[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*_dyld_objc_notify_init)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> struct mach_header* mh)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*_dyld_objc_notify_unmapped)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> struct mach_header* mh)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note: only for use by objc runtime</span></span><br><span class="line"><span class="comment">// Register handlers to be called when objc images are mapped, unmapped, and initialized.</span></span><br><span class="line"><span class="comment">// Dyld will call back the "mapped" function with an array of images that contain an objc-image-info section.</span></span><br><span class="line"><span class="comment">// Those images that are dylibs will have the ref-counts automatically bumped, so objc will no longer need to</span></span><br><span class="line"><span class="comment">// call dlopen() on them to keep them from being unloaded.  During the call to _dyld_objc_notify_register(),</span></span><br><span class="line"><span class="comment">// dyld will call the "mapped" function with already loaded objc images.  During any later dlopen() call,</span></span><br><span class="line"><span class="comment">// dyld will also call the "mapped" function.  Dyld will call the "init" function when dyld would be called</span></span><br><span class="line"><span class="comment">// initializers in that image.  This is when objc calls any +load methods in that image.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped);</span><br></pre></td></tr></table></figure>
<p>请允许我蹩脚的翻译一下其中的部分内容：</p>
<blockquote>
<p>“注册处理程序，以便 oc 的镜像在被 mapped、unmappped 和 initialized 时调用……当 dyld 初始化一个镜像时，会调用 init 函数，镜像的 + load 方法就在这个函数中被调用。”</p>
</blockquote>
<p>（这里的 “init function”，也就是我们上文所说的 <code>load_images</code>）</p>
<p>所以 runtime 其实是注册了三个监听：<code>_dyld_objc_notify_mapped</code> 、 <code>_dyld_objc_notify_init</code> 、 <code>_dyld_objc_notify_unmapped</code>，对应着三个不同的回调。当一个镜像被 mapped、init 和 unmapped 时，dyld 就会通知 runtime 进行相应的处理。</p>
<p> 那么显然，想要解答我们之前遗留的困惑，就需要去看看在 “init” 之前的 “mapped” 中都做了些什么。</p>
<h3 id="map-images"><a href="#map-images" class="headerlink" title="map_images"></a>map_images</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//objc-runtime-new.mm</span></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* map_images</span></span><br><span class="line"><span class="comment">* Process the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">* Calls ABI-agnostic code after taking ABI-specific locks.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">map_images(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span><br><span class="line">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mutex_locker_t</span> lock(runtimeLock);</span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="map-images-nolock"><a href="#map-images-nolock" class="headerlink" title="map_images_nolock"></a>map_images_nolock</h4><p><code>map_images_nolock</code> 的实现比较长，我们忽略掉一些相对不那么重要的内容，然后挑选其中一部分讲讲：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-os.mm</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">map_images_nolock(<span class="keyword">unsigned</span> mhCount, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> mhPaths[],</span><br><span class="line">                  <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> firstTime = YES;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">        sel_init(selrefCount);</span><br><span class="line">        arr_init();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    firstTime = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，当第一次执行时，这里会做一些初始化的操作，下面我们就分别来看一下 <code>sel_init</code> 、 <code>arr_init</code> 、 <code>_read_images</code> 这三步都做了些什么。</p>
<h5 id="sel-init"><a href="#sel-init" class="headerlink" title="sel_init"></a>sel_init</h5><p>顾名思义，这里就是初始化 SEL 的地方，我们前面的问题 <code>SEL SEL_load = NULL;</code> 也将在这里得到解答。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-sel.mm</span></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* sel_init</span></span><br><span class="line"><span class="comment">* Initialize selector tables and register selectors used internally.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sel_init</span><span class="params">(<span class="keyword">size_t</span> selrefCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ...略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register selectors used by libobjc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s(x) SEL_##x = sel_registerNameNoLock(#x, NO)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> t(x,y) SEL_##y = sel_registerNameNoLock(#x, NO)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutex_locker_t</span> lock(selLock);</span><br><span class="line"></span><br><span class="line">    s(load);</span><br><span class="line">    s(initialize);</span><br><span class="line">    t(resolveInstanceMethod:, resolveInstanceMethod);</span><br><span class="line">    t(resolveClassMethod:, resolveClassMethod);</span><br><span class="line">    t(.cxx_construct, cxx_construct);</span><br><span class="line">    t(.cxx_destruct, cxx_destruct);</span><br><span class="line">    s(retain);</span><br><span class="line">    s(release);</span><br><span class="line">    s(autorelease);</span><br><span class="line">    s(retainCount);</span><br><span class="line">    s(alloc);</span><br><span class="line">    t(allocWithZone:, allocWithZone);</span><br><span class="line">    s(dealloc);</span><br><span class="line">    s(copy);</span><br><span class="line">    s(<span class="keyword">new</span>);</span><br><span class="line">    t(forwardInvocation:, forwardInvocation);</span><br><span class="line">    t(_tryRetain, tryRetain);</span><br><span class="line">    t(_isDeallocating, isDeallocating);</span><br><span class="line">    s(retainWeakReference);</span><br><span class="line">    s(allowsWeakReference);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> s</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似地，这里也 <del>偷懒</del> 巧妙的使用了宏定义来起到模板的作用。我们以 <code>load</code> 为🌰，<code>s(load);</code> 相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SEL_load = sel_registerNameNoLock(&quot;load&quot;, NO);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>##</code> 是拼接，<code>#</code> 是转化为字符串</p>
</blockquote>
<p>最终调用的是 <code>__sel_registerName</code>，这里会去一个全局的映射表中进行查找，如果表不存在则创建一个，如果在表中没有找到，则将 SEL name 和 SEL 作为一对 key-value 添加到映射表中。至此我们关于 SEL 的问题便得到了答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-sel.mm</span></span><br><span class="line"><span class="keyword">static</span> SEL __sel_registerName(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> shouldLock, <span class="keyword">bool</span> copy) </span><br><span class="line">&#123;</span><br><span class="line">    SEL result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...略</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (namedSelectors) &#123;</span><br><span class="line">        result = (SEL)NXMapGet(namedSelectors, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!namedSelectors) &#123;</span><br><span class="line">        namedSelectors = NXCreateMapTable(NXStrValueMapPrototype, </span><br><span class="line">                                          (<span class="keyword">unsigned</span>)SelrefCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        result = sel_alloc(name, copy);</span><br><span class="line">        NXMapInsert(namedSelectors, sel_getName(result), result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="arr-init"><a href="#arr-init" class="headerlink" title="arr_init"></a>arr_init</h5><p>回到 <code>map_images_nolock</code> 中，我们继续看另一个初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arr_init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage::init();</span><br><span class="line">    SideTableInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来 <code>AutoreleasePool</code> 和 <code>SideTable</code> 都是在这里初始化的。有的同学可能对 <code>SideTable</code> 比较陌生，大名鼎鼎的引用计数表以及 <code>weak</code> 的实现原理等，全都和它有关。关于 <code>AutoreleasePool</code> 和 <code>SideTable</code>，我们会在其它文章中单独介绍。</p>
<h5 id="read-images"><a href="#read-images" class="headerlink" title="_read_images"></a>_read_images</h5><p>现在 <code>map_images_nolock</code> 中只剩下一个重头戏：<code>_read_images</code> 了。这个方法的实现长得令人发指（400行），<del>笔者已经无力吐槽</del>，主要是检查所有的 header_into，处理其中的 类、分类、协议、消息等信息，插入相应的映射表中。我们摘取其中比较重要的部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm</span></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _read_images</span></span><br><span class="line"><span class="comment">* Perform initial processing of the headers in the linked </span></span><br><span class="line"><span class="comment">* list beginning with headerList. </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Called by: map_images_nolock</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock acquired by map_images</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, <span class="keyword">uint32_t</span> hCount, <span class="keyword">int</span> totalClasses, <span class="keyword">int</span> unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    <span class="function">TimeLogger <span class="title">ts</span><span class="params">(PrintImageTimes)</span></span>;</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    NXCreateHashTable</span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: first time tasks"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    _getObjc2ClassList</span><br><span class="line">    readClass</span><br><span class="line">	ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: discover classes"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    _getObjc2ClassRefs</span><br><span class="line">    remapClassRef</span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: remap classes"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    _getObjc2SelectorRefs</span><br><span class="line">    sel_registerNameNoLock</span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: fix up selector references"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    _getObjc2MessageRefs</span><br><span class="line">    fixupMessageRef</span><br><span class="line">	ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: fix up objc_msgSend_fixup"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    _getObjc2ProtocolList</span><br><span class="line">    readProtocol</span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: discover protocols"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    _getObjc2ProtocolRefs</span><br><span class="line">    remapProtocolRef</span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: fix up @protocol references"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    _getObjc2NonlazyClassList</span><br><span class="line">    realizeClass</span><br><span class="line">	ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: realize non-lazy classes"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    _getObjc2CategoryList</span><br><span class="line">    addUnattachedCategoryForClass</span><br><span class="line">    remethodizeClass</span><br><span class="line">	ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: discover categories"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面每一处都是一次对所有 header_info 的遍历（但其实我不太明白在一次遍历中做这些事不行么？）</p>
<p>这里🍎已经写好了各个步骤耗时的监测，我们看上面的第一行代码：<code>TimeLogger ts(PrintImageTimes);</code> ，我们跳转到 <code>PrintImageTimes</code> 的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// objc-env.h</span><br><span class="line">// OPTION(var, env, help)</span><br><span class="line"></span><br><span class="line">OPTION( PrintImages,              OBJC_PRINT_IMAGES,               &quot;log image and library names as they are loaded&quot;)</span><br><span class="line">OPTION( PrintImageTimes,          OBJC_PRINT_IMAGE_TIMES,          &quot;measure duration of image loading steps&quot;)</span><br><span class="line">OPTION( PrintLoading,             OBJC_PRINT_LOAD_METHODS,         &quot;log calls to class and category +load methods&quot;)</span><br><span class="line">OPTION( PrintInitializing,        OBJC_PRINT_INITIALIZE_METHODS,   &quot;log calls to class +initialize methods&quot;)</span><br><span class="line">OPTION( PrintResolving,           OBJC_PRINT_RESOLVED_METHODS,     &quot;log methods created by +resolveClassMethod: and +resolveInstanceMethod:&quot;)</span><br><span class="line">OPTION( PrintConnecting,          OBJC_PRINT_CLASS_SETUP,          &quot;log progress of class and category setup&quot;)</span><br><span class="line">OPTION( PrintProtocols,           OBJC_PRINT_PROTOCOL_SETUP,       &quot;log progress of protocol setup&quot;)</span><br><span class="line">OPTION( PrintIvars,               OBJC_PRINT_IVAR_SETUP,           &quot;log processing of non-fragile ivars&quot;)</span><br><span class="line">OPTION( PrintVtables,             OBJC_PRINT_VTABLE_SETUP,         &quot;log processing of class vtables&quot;)</span><br><span class="line">OPTION( PrintVtableImages,        OBJC_PRINT_VTABLE_IMAGES,        &quot;print vtable images showing overridden methods&quot;)</span><br><span class="line">OPTION( PrintCaches,              OBJC_PRINT_CACHE_SETUP,          &quot;log processing of method caches&quot;)</span><br><span class="line">OPTION( PrintFuture,              OBJC_PRINT_FUTURE_CLASSES,       &quot;log use of future classes for toll-free bridging&quot;)</span><br><span class="line">OPTION( PrintPreopt,              OBJC_PRINT_PREOPTIMIZATION,      &quot;log preoptimization courtesy of dyld shared cache&quot;)</span><br><span class="line">OPTION( PrintCxxCtors,            OBJC_PRINT_CXX_CTORS,            &quot;log calls to C++ ctors and dtors for instance variables&quot;)</span><br><span class="line">OPTION( PrintExceptions,          OBJC_PRINT_EXCEPTIONS,           &quot;log exception handling&quot;)</span><br><span class="line">OPTION( PrintExceptionThrow,      OBJC_PRINT_EXCEPTION_THROW,      &quot;log backtrace of every objc_exception_throw()&quot;)</span><br><span class="line">OPTION( PrintAltHandlers,         OBJC_PRINT_ALT_HANDLERS,         &quot;log processing of exception alt handlers&quot;)</span><br><span class="line">OPTION( PrintReplacedMethods,     OBJC_PRINT_REPLACED_METHODS,     &quot;log methods replaced by category implementations&quot;)</span><br><span class="line">OPTION( PrintDeprecation,         OBJC_PRINT_DEPRECATION_WARNINGS, &quot;warn about calls to deprecated runtime functions&quot;)</span><br><span class="line">OPTION( PrintPoolHiwat,           OBJC_PRINT_POOL_HIGHWATER,       &quot;log high-water marks for autorelease pools&quot;)</span><br><span class="line">OPTION( PrintCustomRR,            OBJC_PRINT_CUSTOM_RR,            &quot;log classes with un-optimized custom retain/release methods&quot;)</span><br><span class="line">OPTION( PrintCustomAWZ,           OBJC_PRINT_CUSTOM_AWZ,           &quot;log classes with un-optimized custom allocWithZone methods&quot;)</span><br><span class="line">OPTION( PrintRawIsa,              OBJC_PRINT_RAW_ISA,              &quot;log classes that require raw pointer isa fields&quot;)</span><br><span class="line"></span><br><span class="line">OPTION( DebugUnload,              OBJC_DEBUG_UNLOAD,               &quot;warn about poorly-behaving bundles when unloaded&quot;)</span><br><span class="line">OPTION( DebugFragileSuperclasses, OBJC_DEBUG_FRAGILE_SUPERCLASSES, &quot;warn about subclasses that may have been broken by subsequent changes to superclasses&quot;)</span><br><span class="line">OPTION( DebugNilSync,             OBJC_DEBUG_NIL_SYNC,             &quot;warn about @synchronized(nil), which does no synchronization&quot;)</span><br><span class="line">OPTION( DebugNonFragileIvars,     OBJC_DEBUG_NONFRAGILE_IVARS,     &quot;capriciously rearrange non-fragile ivars&quot;)</span><br><span class="line">OPTION( DebugAltHandlers,         OBJC_DEBUG_ALT_HANDLERS,         &quot;record more info about bad alt handler use&quot;)</span><br><span class="line">OPTION( DebugMissingPools,        OBJC_DEBUG_MISSING_POOLS,        &quot;warn about autorelease with no pool in place, which may be a leak&quot;)</span><br><span class="line">OPTION( DebugPoolAllocation,      OBJC_DEBUG_POOL_ALLOCATION,      &quot;halt when autorelease pools are popped out of order, and allow heap debuggers to track autorelease pools&quot;)</span><br><span class="line">OPTION( DebugDuplicateClasses,    OBJC_DEBUG_DUPLICATE_CLASSES,    &quot;halt when multiple classes with the same name are present&quot;)</span><br><span class="line">OPTION( DebugDontCrash,           OBJC_DEBUG_DONT_CRASH,           &quot;halt the process by exiting instead of crashing&quot;)</span><br><span class="line"></span><br><span class="line">OPTION( DisableVtables,           OBJC_DISABLE_VTABLES,            &quot;disable vtable dispatch&quot;)</span><br><span class="line">OPTION( DisablePreopt,            OBJC_DISABLE_PREOPTIMIZATION,    &quot;disable preoptimization courtesy of dyld shared cache&quot;)</span><br><span class="line">OPTION( DisableTaggedPointers,    OBJC_DISABLE_TAGGED_POINTERS,    &quot;disable tagged pointer optimization of NSNumber et al.&quot;) </span><br><span class="line">OPTION( DisableTaggedPointerObfuscation, OBJC_DISABLE_TAG_OBFUSCATION,    &quot;disable obfuscation of tagged pointers&quot;)</span><br><span class="line">OPTION( DisableNonpointerIsa,     OBJC_DISABLE_NONPOINTER_ISA,     &quot;disable non-pointer isa fields&quot;)</span><br><span class="line">OPTION( DisableInitializeForkSafety, OBJC_DISABLE_INITIALIZE_FORK_SAFETY, &quot;disable safety checks for +initialize after fork&quot;)</span><br></pre></td></tr></table></figure>
<p>(<em>@ο@</em>) 哇～偌大的一个宝库！这里定义了大量的运行时环境变量，如果开启的话，不仅有助于我们学习 runtime 的源码，也大大方便了负责性能优化的同学做一些统计的耗时等。</p>
<p>我们就以刚刚说到的 <code>PrintImageTimes</code> 为例，它对应的运行时环境变量为 <code>OBJC_PRINT_IMAGE_TIMES</code> ，我们在 Xcode -&gt; Project -&gt; Scheme -&gt; Edit Scheme 中将该环境变量设为 YES：</p>
<p><img src="/2019/05/16/Runtime 温故而知新/Runtime_PrintOption_PrintImageTimes.png" alt="Runtime_PrintOption_PrintImageTimes"></p>
<p>运行程序，就可以方便地看到各阶段的耗时了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">objc[<span class="number">40242</span>]: <span class="number">0.39</span> ms: IMAGE TIMES: first time tasks</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">18.40</span> ms: IMAGE TIMES: discover classes</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">0.00</span> ms: IMAGE TIMES: remap classes</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">100.89</span> ms: IMAGE TIMES: fix up selector references</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">0.14</span> ms: IMAGE TIMES: fix up objc_msgSend_fixup</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">2.47</span> ms: IMAGE TIMES: discover protocols</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">0.67</span> ms: IMAGE TIMES: fix up @protocol references</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">3.50</span> ms: IMAGE TIMES: realize non-lazy classes</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">0.00</span> ms: IMAGE TIMES: realize future classes</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">3.00</span> ms: IMAGE TIMES: discover categories</span><br><span class="line"><span class="number">2019</span><span class="number">-04</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">02.921120</span>+<span class="number">0800</span> debug-objc[<span class="number">40242</span>:<span class="number">2106148</span>] Hello, World!</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/16/Runtime 温故而知新/Runtime_Process.png" alt="runtime_process"></p>
<h2 id="initialize"><a href="#initialize" class="headerlink" title="+ initialize"></a>+ initialize</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// ViewController.m</span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface SubViewController : ViewController</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubViewController</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;SubViewController initialize...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;ViewController initialize...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    SubViewController *subVC = [[SubViewController alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    </span><br><span class="line">2019-05-15 16:55:02.331135+0800 Test[25870:1727530] ViewController initialize...</span><br><span class="line">2019-05-15 16:55:02.334713+0800 Test[25870:1727530] SubViewController initialize...</span><br></pre></td></tr></table></figure>
<p>那么如果我们把子类中的 <code>+ initialize</code> 删掉，会是什么样呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// ViewController.m</span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface SubViewController : ViewController</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubViewController</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;ViewController initialize... self = %@&quot;, self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    SubViewController *subVC = [[SubViewController alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    </span><br><span class="line">2019-05-15 16:55:50.386359+0800 Test[25907:1728843] ViewController initialize... self = ViewController</span><br><span class="line">2019-05-15 16:55:50.390092+0800 Test[25907:1728843] ViewController initialize... self = SubViewController</span><br></pre></td></tr></table></figure>
<p>查看源码，可以发现 <code>initialize</code> 的调用是通过 <code>objc_msgSend</code>，所以如果子类没有实现，则会调用父类的方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callInitialize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说如果我们不加判断的话，一个类的 initialize 可能会执行多次，而这并不一定是我们想要的。</p>
<p>Q：那么有的同学可能会说，如果我们没有子类，或者子类实现了 <code>+ initialize</code> 不就没问题了么？</p>
<p>A：❌。我们来看下面这个🌰，现在我们让子类实现 <code>+ initialize</code>，这样子类就不会再调用父类的 <code>+initialize</code>了。然后我们给父类添加一个 KVO，猜猜现在输出是什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// ViewController.m</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface SubViewController : ViewController</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubViewController</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;SubViewController initialize...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong) SubViewController *subVC;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;ViewController initialize... self = %@&quot;, self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.subVC = [[SubViewController alloc] init];</span><br><span class="line">    </span><br><span class="line">    [self addObserver:self forKeyPath:@&quot;view&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self removeObserver:self forKeyPath:@&quot;view&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    </span><br><span class="line">2019-05-15 16:52:14.792672+0800 Test[25830:1725181] ViewController initialize... self = ViewController</span><br><span class="line">2019-05-15 16:52:14.796562+0800 Test[25830:1725181] SubViewController initialize...</span><br><span class="line">2019-05-15 16:52:14.796983+0800 Test[25830:1725181] ViewController initialize... self = NSKVONotifying_ViewController</span><br></pre></td></tr></table></figure>
<p><code>ViewController</code> 的 <code>+ initialize</code> 还是被调用了两次。这是因为 KVO 动态地创建了一个子类（<code>NSKVONotifying_ViewController</code>），而这个子类不会重写 <code>+ initialize</code>，所以父类的 <code>+ initialize</code> 就又被调用了。</p>
<p>那么我们该如何解决呢？🍎 的文档中说：“If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (void)initialize &#123;</span><br><span class="line">    if (self == [ClassName self]) &#123;</span><br><span class="line">        // ... do the initialization ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p>Q：如果一个类实现了 <code>+ load</code> 方法，但是这个类没有被使用（import），那么它还会在 load_images 时加载嘛？<br>A：会。</p>
<p>Q：如果一个类实现了 <code>+ load</code> 方法，但是具体实现内容是空，那么还会在 load_images 时被加载嘛？<br>A：会。</p>
<p>Q：同一个镜像中，多个不同的类、多个不同的分类的 <code>+ load</code> 调用顺序是怎样的？<br>A：编译顺序。</p>
<p>Q：同一个镜像中，NonLazyClassA 依赖了 NonLazyClassB，那么它们的 <code>+ load</code> 调用顺序是怎样的？<br>A：还是编译顺序。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/objc4/</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2016/406" target="_blank" rel="noopener">https://developer.apple.com/videos/play/wwdc2016/406</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048</a></li>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.html" target="_blank" rel="noopener">https://www.mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.html</a></li>
<li><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc" target="_blank" rel="noopener">http://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc</a></li>
<li><a href="https://nshipster.com/method-swizzling/" target="_blank" rel="noopener">https://nshipster.com/method-swizzling/</a></li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Runtime/" rel="tag"># Runtime</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/02/SpriteKit 开发游戏实战——《OverTheMountains》/" rel="next" title="SpriteKit 开发游戏实战——《OverTheMountains》">
                <i class="fa fa-chevron-left"></i> SpriteKit 开发游戏实战——《OverTheMountains》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="gitalk-container">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">iCodeWoods</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/iCodeWoods" title="GitHub &rarr; https://github.com/iCodeWoods" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Runtime"><span class="nav-number">1.</span> <span class="nav-text">Runtime</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#load"><span class="nav-number">1.1.</span> <span class="nav-text">+ load</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#load-images"><span class="nav-number">1.1.1.</span> <span class="nav-text">load_images</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#hasLoadMethods"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">hasLoadMethods</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#getObjc2NonlazyClassList"><span class="nav-number">1.1.1.1.1.</span> <span class="nav-text">_getObjc2NonlazyClassList</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#getDataSection"><span class="nav-number">1.1.1.1.2.</span> <span class="nav-text">getDataSection</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prepare-load-methods"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">prepare_load_methods</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#schedule-class-load"><span class="nav-number">1.1.1.2.1.</span> <span class="nav-text">schedule_class_load</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#add-category-to-loadable-list"><span class="nav-number">1.1.1.2.2.</span> <span class="nav-text">add_category_to_loadable_list</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#remapClass"><span class="nav-number">1.1.1.2.3.</span> <span class="nav-text">remapClass</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#call-load-methods"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">call_load_methods</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#call-class-loads"><span class="nav-number">1.1.1.3.1.</span> <span class="nav-text">call_class_loads</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Producer-Consumer"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">Producer-Consumer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#loadMethodLock"><span class="nav-number">1.1.1.4.1.</span> <span class="nav-text">loadMethodLock</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#objc-init"><span class="nav-number">1.2.</span> <span class="nav-text">_objc_init</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dyld-objc-notify-register"><span class="nav-number">1.2.1.</span> <span class="nav-text">_dyld_objc_notify_register</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-images"><span class="nav-number">1.2.2.</span> <span class="nav-text">map_images</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#map-images-nolock"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">map_images_nolock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#sel-init"><span class="nav-number">1.2.2.1.1.</span> <span class="nav-text">sel_init</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#arr-init"><span class="nav-number">1.2.2.1.2.</span> <span class="nav-text">arr_init</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#read-images"><span class="nav-number">1.2.2.1.3.</span> <span class="nav-text">_read_images</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#initialize"><span class="nav-number">1.3.</span> <span class="nav-text">+ initialize</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QA"><span class="nav-number">1.4.</span> <span class="nav-text">QA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#References"><span class="nav-number">1.5.</span> <span class="nav-text">References</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">iCodeWoods</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>



  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  
    

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">



<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: 'd38fffaa5076f5638652',
    clientSecret: '399d468bb9fe3743df10c6e2ee129a9da0af49cb',
    repo: 'iCodeWoods.github.io',
    owner: 'iCodeWoods',
    admin: ['iCodeWoods'],
    id: md5(location.pathname),
    
      language: window.navigator.language || window.navigator.userLanguage,
    
    distractionFreeMode: 'true'
  });
  gitalk.render('gitalk-container');
</script>

  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
