<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>iCodeWoods的小站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="iCodeWoods的小站">
<meta property="og:url" content="https://iCodeWoods.github.io/index.html">
<meta property="og:site_name" content="iCodeWoods的小站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iCodeWoods的小站">
  
    <link rel="alternate" href="/atom.xml" title="iCodeWoods的小站" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">iCodeWoods的小站</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">片刻之欢愉，不如须臾之宁静</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://iCodeWoods.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-《1984》读书笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/12/《1984》读书笔记/" class="article-date">
  <time datetime="2019-03-12T05:42:40.000Z" itemprop="datePublished">2019-03-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书笔记/">读书笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/12/《1984》读书笔记/">《1984》读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>战争就是和平</p>
<p>自由就是奴役</p>
<p>无知就是力量</p>
</blockquote>
<p>开卷就看到如此荒诞不已的文字，而接下来的故事也果然没有辜负这份荒诞。。。</p>
<p>起初心里觉得这就是一个外国人编造的一个外国的荒诞的虚假故事而已，和我们没有什么关系，也不可能发生在我们身上。</p>
<p>结果越往后读，心里越是震惊，读到大概一半的时候，感觉心里恍然大悟。书中的描述看似荒诞不羁，但其实我们的现实生活就是类似的啊！</p>
<p>那我们为什么没有感知到呢？会不会是因为我们其实已经受到了“真理部”的影响？我们的一切是否都在“思想警察”的监视之下？说句可能大逆不道的话，从某种程度上说，我们无疑是的，只是不如书中的“党”那样过分与夸张罢了。</p>
<p>女票最近在看《改革开放中的邓小平》，昨晚和她讨论了一些问题，现在想来竟然有那么一点像书中的男主角温斯顿，不过好在我的女票并不是凯瑟琳，而是茱莉亚，她很快就明白了我所表达的意思：</p>
<ul>
<li>为什么新闻总是报道外国多么多么不好，多么多么混乱，但是那些有钱人们却在拼命地往外国移民？所谓的众生平等是真实的，还是上层阶级的人所灌输给下层阶级的人的一种思想罢了？</li>
<li>最近有篇文章很火，《当满大街都是外卖骑手，上百万劳动力是否用错了地方?》起初看到这个题目，我也只是按着其字面意思进行了一个极为浅显的思考。但当我看到一些网友的评论时，却发现了很多不同的声音：“工资多少咱先不提，工资从未按月发放，每天看着车间主人的驴脸，毫无升职上升空间，上班的心情比上坟还沉重”、“廉价劳动力不是工厂造成的。美国人工成本是中国的八倍，但是在美国办企业比在大陆还赚钱，钱被谁抽走了一比较就知道了”。看起来，真正的井底之蛙其实只是我自己罢了，有思想、有见识的人大把存在。</li>
</ul>
<p>读完后查阅资料，原来这本书是作者在1948年写的，1984是三十多年后了，而我现在看这本书（2019年）又是它的三十多年后，经历了两个三十多年，初读起来却感觉近在咫尺，确实写得很好。</p>
<blockquote>
<p>他们不觉悟，就永远不会反抗；而不反抗，他们就无法觉悟。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://iCodeWoods.github.io/2019/03/12/《1984》读书笔记/" data-id="cjt5cp7ju00072b99e2iikltx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Books/">Books</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2018年总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/03/2018年总结/" class="article-date">
  <time datetime="2019-01-03T05:34:52.000Z" itemprop="datePublished">2019-01-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/杂/">杂</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/03/2018年总结/">2018年总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><p>8102 年是我来到网易的第三年、来到 NB iOS Team 的第二年。</p>
<p>这一年我的输入不少，但输出不多；</p>
<p>这一年我犯的错误不少，但做的总结/反思不多；</p>
<p>总体而言，尽管有不足之处，但感觉无论是自己还是整个团队，这一年的进步都很大。</p>
<h1 id="8102-年的工作与输出"><a href="#8102-年的工作与输出" class="headerlink" title="8102 年的工作与输出"></a>8102 年的工作与输出</h1><p><strong>关于工作</strong></p>
<p>Emmm，工作在绩效评估表里都有，略</p>
<p><strong>关于分享</strong></p>
<p>8102 年我在团队内部应该是一共分享了六次：《网易新闻Fastlane功能梳理》、《Texture》、《202_whats_new_in_cocoa_touch》、《AR业务梳理》、《NTESPopuper》、《Fastlane是如何执行起来的》</p>
<p>次数虽然不少，但其实存在很多问题：</p>
<ul>
<li>深度不够</li>
<li>易紧张，控制不好分享的节奏</li>
<li>分享/表达/总结（Emmm，不知如何形容这种能力）的能力不足。举个例子：《Refactoring》中有一个“两顶帽子”的比喻：“使用重构技术开发软件时，你把自己的时间分配给两种截然不同的行为：添加新功能，以及重构。。。。。。你可能会发现自己经常变换帽子。。。。。但无论何时你都应该清楚自己戴的是哪一顶帽子。”而我在分享弹窗梳理重构时，就犯了这样的错误：我没有清楚地意识到自己是要讲新弹窗系统的用法，还是要讲它的实现细节，于是导致我在分享时“同时戴了两顶帽子”，最终的分享效果自己很不满意。</li>
</ul>
<p><strong>关于博客</strong></p>
<p>8102 年写的博客不多，而且基本都没什么技术含量（大部分都是读书笔记QAQ），不提也罢。。。</p>
<h1 id="8102-年的学习、成长与收获"><a href="#8102-年的学习、成长与收获" class="headerlink" title="8102 年的学习、成长与收获"></a>8102 年的学习、成长与收获</h1><h2 id="8102-年我的学习、成长与收获"><a href="#8102-年我的学习、成长与收获" class="headerlink" title="8102 年我的学习、成长与收获"></a>8102 年我的学习、成长与收获</h2><p><strong>架构与模块</strong></p>
<p>虽然只是了解了点皮毛😁，不过还是很高兴的。感觉明确了一个方向，行动起来效率更高了。</p>
<p>例如在做弹窗气泡的梳理重构时，从鑫飞那学到了一些抽象的思想，实现了弹窗调用方与实现方的解耦。</p>
<p>还有做跟贴重构时，与黄旭的大量讨论，使我逐渐清晰了对 MVP、VIPER 等的理解，头脑中形成了分层的思想，也对各种之前常挂在嘴边的“可扩展性”、“可XX性”有了进一步的认识。</p>
<p>脑图与类图不知算不算是这部分里的，暂且先写在这段。8102 年的另一大收获就是，从庞博那里学到了一些类图的知识（从架构组的每个大佬那都学了点啊哈哈哈）。希望自己能养成一个画脑图、类图的好习惯吧。</p>
<p><strong>CI/CD 与 脚本</strong></p>
<p>这一年学到了不少 CI/CD 方面的知识，也总算是在年尾的时候，通过阅读 Fastlane 的源码勉强学会了一丢丢 Ruby 的语法（离入门还差得远😅）</p>
<p>在这个过程中也学了点 bash（Emmm也没学会），还学了点简单的基本技能，比如给 Mac 添加定时任务之类的。</p>
<p><strong>书籍与博客</strong></p>
<p>这一年我读了二十本书，但是上半年读的书基本都和技术无关，而下半年虽然开始看一些技术相关的书，但基本上都没读完😅总体而言下半年读书比上半年少了（时间都去哪了？）</p>
<ul>
<li>《偷影子的人》</li>
<li>《追风筝的人》</li>
<li>《老人与海》</li>
<li>《许三观卖血记》</li>
<li>《活着》</li>
<li>《兄弟》</li>
<li>《好吗好的》——未读完</li>
<li>《沉睡的人鱼之家》</li>
<li>《长安十二时辰》</li>
<li>《第七天》</li>
<li>《无人生还》</li>
<li>《四世同堂》</li>
<li>《日常生活中的发明原理》——未读完</li>
<li>《黄金时代》</li>
<li>《理性的非理性》——未读完</li>
<li>《浪潮之巅》——未读完</li>
<li>《乔布斯传》——未读完</li>
<li>《Refactoring》——未读完</li>
<li>《从零开始学架构》——未读完</li>
</ul>
<p>讲道理，这一年我看的博客应该有百八十篇了吧。？比较开心的是，有时能够通过浏览一个好的博客，而发现另一个好博客。收获固然很多，但没有被完全消化的则更多得多。</p>
<h2 id="8102-年我眼中团队的成长与收获"><a href="#8102-年我眼中团队的成长与收获" class="headerlink" title="8102 年我眼中团队的成长与收获"></a>8102 年我眼中团队的成长与收获</h2><p>在我看来，和 7102 年相比，8102 年团队的进步真的是巨大的。</p>
<p>感受最深的一点就是，架构组与他们所作出的贡献（我就没必要在这罗列了）。和他们一比，真是瞬间感觉自己所做的工作太微不足道了。说实话，他们真的是我目前可见的一个未来的方向。其实自己之所以会看重构/架构等相关的书籍，除了自身原因以外，团队的环境/氛围也是一大主因。</p>
<p>8102 年团队的各方面氛围都比以前有很大进步，比如与安卓的交流变多了，比如我们开始使用 issues 进行一些讨论，比如我们刚刚诞生的微信公众号，比如我们有了技术设计评审，再比如我们有了现在的这个年终小结（认真脸，这个真的是件好事）。</p>
<p>还有一方面，举个可能不太恰当的例子：拿破仑曾经说过:“一头狮子率领的一群绵羊,可以打败由一头绵羊带领的一群狮子!” 18 年的团队感觉就像是由一头狮子率领着（但17年并不是由绵羊率领啦QAQ），做了大量的技术方面的优化与积累，于团队整体而言大有裨益。而17年就没有这种感觉，因此17年就会出现一种奇怪的现象：大家都在做着自己的本职工作，而我这个小菜鸟却在咋咋呼呼地做着一些其实很小很简单的技术优化，比如容器类添加ntes_前缀的安全访问方法，比如利用GCDWebServer实时访问沙盒等等，和18年团队所做的这些技术优化相比就是小巫见大巫了。</p>
<h1 id="8102-年的反思与不足"><a href="#8102-年的反思与不足" class="headerlink" title="8102 年的反思与不足"></a>8102 年的反思与不足</h1><h2 id="8102-年个人的不足"><a href="#8102-年个人的不足" class="headerlink" title="8102 年个人的不足"></a>8102 年个人的不足</h2><p>不足之处真的是太多了。。。要真写得写一大篇，这里只能先挑一部分写出来了：</p>
<ul>
<li>自测不足：其实很多 bug 都是可以在自测阶段发现的，但我却常常因各种主观、客观的原因（条件难触发/没有数据/后台没上线/切换模拟器或分支编译时间太长等）而没有做好充足的自测。</li>
<li>表达能力不足：尽管这一年里我作了不少次的分享（甚至有可能是组内最多的），但我其实对自己分享的效果都不是很满意。每一次分享结束回到家后，我总是会反思与懊悔：“唉那个地方忘了讲了”、“这个地方当时要是这么讲就好了”，然而没有后悔药了😭今年双十一买了《影响力》、《社会心理学》、《演讲的力量》等书，还没来得及看，希望能帮助我在新的一年提升自己的表达能力</li>
<li>技能树不足：有一次坐地铁时，鑫飞大佬和我说：“感觉 iOS 就三大块：TableView、WebView、视频”，然鹅，我对WebView 与视频近乎一窍不通，对重构后的首页新列表也不熟悉。感觉这些是我的实力方面的硬伤。</li>
</ul>
<p>在生活方面，来公司之后胖了20斤。。。QAQ，也没怎么锻炼，希望新的一年能坚持锻炼吧。另外，18年上半年自己还是能做到早睡早起的，每天都能早早地来到公司。而下半年就变成晚睡晚起了😂，希望19年能变回去吧～哦对了，之前坚持写的日记，后来渐渐的变成了“周记”，现在已经变成“月记”了😂</p>
<h2 id="8102-年我眼中团队的不足"><a href="#8102-年我眼中团队的不足" class="headerlink" title="8102 年我眼中团队的不足"></a>8102 年我眼中团队的不足</h2><p>我对团队也有很多不熟悉的地方，这里仅从我个人的角度出发，不代表正确。</p>
<p>其实团队的不足，几乎都不是 8102 年产生的，大部分都是天放与鑫飞所说的“欠下的技术债”。</p>
<ul>
<li>文档仍然不足</li>
<li>废弃代码多</li>
<li>代码警告太多</li>
<li>与测试的沟通不足：例如之前提到的，开发的脑图与测试的脑图如何能结合一下，或是互相参考一下</li>
<li>讨论交流感觉不够，比较明显能看出来的一点就是，大多数人不看也不提issues。其实每个人肯定都是有一些想法的，但不知道是出于哪些原因没有说出来。同时要是每个人都能参与讨论就好了，当然这很难，每个人的性格都是不一样的。还有一点就是，其实很多人平时都会看一些技术文章，如果大家能把认为好的文章同步到群里之类的就更好了（当然我也没做到这点，因为感觉大家都不发，就我自己发会很奇怪。。。）</li>
</ul>
<h1 id="9102-年的计划与-flag"><a href="#9102-年的计划与-flag" class="headerlink" title="9102 年的计划与 flag"></a>9102 年的计划与 flag</h1><p><strong>工作方面</strong></p>
<ul>
<li>设计模式：在这一年的工作与学习中，深深地感受到自己设计模式知识的匮乏。无论是平时的重构工作，还是长远来看的架构相关，都必须要有设计模式作为基础，新的一年希望自己能够读完经典的《设计模式》一书，掌握并运用一些设计模式</li>
<li>Ruby：得益于 DSL 的简易性，不会 Ruby 的我竟然一直在开发/维护着 CI/CD 相关的功能。但正如8102年最后一次周会我分享时所说的那样，新的一年里希望自己能够“从幼稚走向成熟”。此外也希望自己能写出一些方便自己与他人使用的脚本，将知识运用到生产环节</li>
<li>新列表：这一年里虽然没少参与业务迭代与技术重构等工作，但神奇的是竟然一次也没有分到过新列表相关的需求。。。虽然鑫飞分享过新列表，但我其实对新列表还是很不熟悉，新的一年里希望自己能够搞定这块</li>
<li>分享：9102 年自己的分享希望能不少于今年吧（感觉气势很弱的说…）其实这也得益于之前看的一篇文章，关于学习的金字塔，听讲/阅读这类被动学习的学习内容留存率是最低的，教授给他人这类的主动学习才能够记住更多的内容。因此分享于公于私都是件好事</li>
<li>Push：这块本身自己就不是很熟，需要学习，更何况现在老大想把这块工作分配给我，就更需要搞明白了。这里顺便立个小flag，19年至少要做一次Push相关的分享</li>
<li>视频、正文：Emmm，为什么这俩放到一起说了呢，因为感觉这俩都很难搞啊QAQ，一直以来的硬伤。。。</li>
</ul>
<p>哦还有，希望自己19年能在团队的公众号上发表一篇文章吧～</p>
<p>19 年会花更多精力在“修炼内功”上。这取决于各方面原因吧，其中一点想提一下就是，平时看各种文章时，总会看到一些诸如“iOS 不行了”，“大前端时代来了”balabala的，就会莫名的产生焦虑。但实际上如果去学习那些雨后春笋般所谓的新技术，不过是一些上层的框架罢了，瞬息万变，只有内功才永远不会过时。</p>
<p><strong>非工作方面</strong></p>
<ul>
<li>坚持写日记，至少不能再是“月记”了，起码也得是周记吧QAQ</li>
<li>坚持锻炼，现在的体重应该刚好，不能再重了。。。</li>
<li>早睡早起，能不迟到。。。</li>
<li>真正有质量的博客输出</li>
<li>读至少20本书</li>
</ul>
<p>2019年，加油！</p>
<p><img src="/2019/01/03/2018年总结/Fightting.png" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://iCodeWoods.github.io/2019/01/03/2018年总结/" data-id="cjt5cp7ks001u2b99x9lf62g4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/杂/">杂</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-《Refactoring》读书笔记（四）重新组织数据" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/10/《Refactoring》读书笔记（四）重新组织数据/" class="article-date">
  <time datetime="2018-12-10T05:37:18.000Z" itemprop="datePublished">2018-12-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书笔记/">读书笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/10/《Refactoring》读书笔记（四）重新组织数据/">《Refactoring》读书笔记（四）重新组织数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="第八章-重新组织数据"><a href="#第八章-重新组织数据" class="headerlink" title="第八章 重新组织数据"></a>第八章 重新组织数据</h1><h2 id="8-1-Self-Encapsulate-Field（自封装字段）"><a href="#8-1-Self-Encapsulate-Field（自封装字段）" class="headerlink" title="8.1 Self Encapsulate Field（自封装字段）"></a>8.1 Self Encapsulate Field（自封装字段）</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。</p>
<p><strong>为这个字段建立取值/设值函数，并且只以这些函数来访问字段。</strong></p>
<p>（文中提到的两种观点，有点类似于我们 iOS 开发中的 “self.xxx 与 _xxx”）</p>
<h2 id="8-2-Replace-Data-Value-with-Object（以对象取代数据值）"><a href="#8-2-Replace-Data-Value-with-Object（以对象取代数据值）" class="headerlink" title="8.2 Replace Data Value with Object（以对象取代数据值）"></a>8.2 Replace Data Value with Object（以对象取代数据值）</h2><h3 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h3><p>你有一个数据项，需要与其他数据和行为一起使用才有意义。</p>
<p><strong>将数据项变成对象。</strong></p>
<h2 id="8-3-Change-Value-to-Reference（将值对象改为引用对象）"><a href="#8-3-Change-Value-to-Reference（将值对象改为引用对象）" class="headerlink" title="8.3 Change Value to Reference（将值对象改为引用对象）"></a>8.3 Change Value to Reference（将值对象改为引用对象）</h2><h3 id="概要-2"><a href="#概要-2" class="headerlink" title="概要"></a>概要</h3><p>你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。</p>
<p><strong>将这个值对象变成引用对象。</strong></p>
<h2 id="8-4-Change-Reference-to-Value（将引用对象改为值对象）"><a href="#8-4-Change-Reference-to-Value（将引用对象改为值对象）" class="headerlink" title="8.4 Change Reference to Value（将引用对象改为值对象）"></a>8.4 Change Reference to Value（将引用对象改为值对象）</h2><h3 id="概要-3"><a href="#概要-3" class="headerlink" title="概要"></a>概要</h3><p>你有一个引用对象，很小且不可变，而且不易管理。</p>
<p><strong>将它变成一个值对象。</strong></p>
<h2 id="8-5-Replace-Array-with-Object（以对象取代数组）"><a href="#8-5-Replace-Array-with-Object（以对象取代数组）" class="headerlink" title="8.5 Replace Array with Object（以对象取代数组）"></a>8.5 Replace Array with Object（以对象取代数组）</h2><h3 id="概要-4"><a href="#概要-4" class="headerlink" title="概要"></a>概要</h3><p>你有一个数组，其中的元素各自代表不同的东西。</p>
<p><strong>以对象替换数组。对于数组中的每个元素，以一个字段来表示。</strong></p>
<h2 id="8-6-Duplicate-Observed-Data（复制“被监视数据”）"><a href="#8-6-Duplicate-Observed-Data（复制“被监视数据”）" class="headerlink" title="8.6 Duplicate Observed Data（复制“被监视数据”）"></a>8.6 Duplicate Observed Data（复制“被监视数据”）</h2><h3 id="概要-5"><a href="#概要-5" class="headerlink" title="概要"></a>概要</h3><p>你有一些领域数据置身于GUI控件中，而领域函数需要访问这些数据。</p>
<p><strong>将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。</strong></p>
<h2 id="8-7-Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）"><a href="#8-7-Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）" class="headerlink" title="8.7 Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）"></a>8.7 Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）</h2><h3 id="概要-6"><a href="#概要-6" class="headerlink" title="概要"></a>概要</h3><p>两个类都需要使用对方特性，但其间只有一条单向连接。</p>
<p><strong>添加一个反向指针，并使修改函数能够同时更新两条连接。</strong></p>
<h2 id="8-8-Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）"><a href="#8-8-Change-Bidirectional-Association-to-Unidirectional（将双向关联改为单向关联）" class="headerlink" title="8.8 Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）"></a>8.8 Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）</h2><h3 id="概要-7"><a href="#概要-7" class="headerlink" title="概要"></a>概要</h3><p>两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。</p>
<p><strong>去除不必要的关联。</strong></p>
<h2 id="8-9-Replace-Magic-Number-with-Symbolic-Constant（以字面常量取代魔法数）"><a href="#8-9-Replace-Magic-Number-with-Symbolic-Constant（以字面常量取代魔法数）" class="headerlink" title="8.9 Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）"></a>8.9 Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）</h2><h3 id="概要-8"><a href="#概要-8" class="headerlink" title="概要"></a>概要</h3><p>你有一个字面数值，常有特别含义。</p>
<p><strong>创造一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量。</strong></p>
<h2 id="8-10-Encapsulate-Field（封装字段）"><a href="#8-10-Encapsulate-Field（封装字段）" class="headerlink" title="8.10 Encapsulate Field（封装字段）"></a>8.10 Encapsulate Field（封装字段）</h2><h3 id="概要-9"><a href="#概要-9" class="headerlink" title="概要"></a>概要</h3><p>你的类中存在一个public字段。</p>
<p><strong>将它声明为private，并提供相应的访问函数。</strong></p>
<h2 id="8-11-Encapsulate-Collection（封装集合）"><a href="#8-11-Encapsulate-Collection（封装集合）" class="headerlink" title="8.11 Encapsulate Collection（封装集合）"></a>8.11 Encapsulate Collection（封装集合）</h2><h3 id="概要-10"><a href="#概要-10" class="headerlink" title="概要"></a>概要</h3><p>有个函数返回一个集合。</p>
<p><strong>让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。</strong></p>
<h2 id="8-12-Replace-Record-with-Data-Class（以数据类取代记录）"><a href="#8-12-Replace-Record-with-Data-Class（以数据类取代记录）" class="headerlink" title="8.12 Replace Record with Data Class（以数据类取代记录）"></a>8.12 Replace Record with Data Class（以数据类取代记录）</h2><h3 id="概要-11"><a href="#概要-11" class="headerlink" title="概要"></a>概要</h3><p>你需要面对传统编程环境中的记录结构。</p>
<p><strong>为该记录创建一个“哑”数据对象。</strong></p>
<h2 id="8-13-Replace-Type-Code-with-Class（以类取代类型码）"><a href="#8-13-Replace-Type-Code-with-Class（以类取代类型码）" class="headerlink" title="8.13 Replace Type Code with Class（以类取代类型码）"></a>8.13 Replace Type Code with Class（以类取代类型码）</h2><h3 id="概要-12"><a href="#概要-12" class="headerlink" title="概要"></a>概要</h3><p>类之中有一个数值类型码，但它并不影响类的行为。</p>
<p><strong>以一个新的类替换该数值类型码。</strong></p>
<h2 id="8-14-Replace-Type-Code-with-Subclasses（以子类取代类型码）"><a href="#8-14-Replace-Type-Code-with-Subclasses（以子类取代类型码）" class="headerlink" title="8.14 Replace Type Code with Subclasses（以子类取代类型码）"></a>8.14 Replace Type Code with Subclasses（以子类取代类型码）</h2><h3 id="概要-13"><a href="#概要-13" class="headerlink" title="概要"></a>概要</h3><p>你有一个不可变的类型码，它会影响类的行为。</p>
<p><strong>以子类取代这个类型码。</strong></p>
<h2 id="8-15-Replace-Type-Code-with-State-Strategy（以-state-strategy-取代类型码）"><a href="#8-15-Replace-Type-Code-with-State-Strategy（以-state-strategy-取代类型码）" class="headerlink" title="8.15 Replace Type Code with State/Strategy（以 state/strategy 取代类型码）"></a>8.15 Replace Type Code with State/Strategy（以 state/strategy 取代类型码）</h2><h3 id="概要-14"><a href="#概要-14" class="headerlink" title="概要"></a>概要</h3><p>你有一个类型码，它会影响类的行为，但你无法通过继承手法消除它。</p>
<p><strong>以状态对象取代类型码。</strong></p>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>本项重构和 Replace Type Code with Subclasses（223）很相似，但如果“类型码的值在对象生命周期中发生变化”或“其它原因使得宿主类不能被继承”，你也可以使用本重构。</p>
<p>State模式和Strategy模式非常相似，重构过程是相同的，选择哪个模式并非问题关键所在。如果你打算在完成本项重构后再以 Replace Conditional with Polymorphism（255）简化一个算法，那么选择 Strategy 模式比较合适；如果你打算搬移与状态相关的数据，而且你把新建对象视为一种变迁状态，就应该选择使用 State 模式。</p>
<h2 id="8-16-Replace-Subclass-with-Fields（以字段取代子类）"><a href="#8-16-Replace-Subclass-with-Fields（以字段取代子类）" class="headerlink" title="8.16 Replace Subclass with Fields（以字段取代子类）"></a>8.16 Replace Subclass with Fields（以字段取代子类）</h2><h3 id="概要-15"><a href="#概要-15" class="headerlink" title="概要"></a>概要</h3><p>你的各个子类的唯一差别只在“返回常量数据”的函数身上。</p>
<p><strong>修改这些函数，使他们返回超类中的某个（新增）字段，然后销毁子类。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://iCodeWoods.github.io/2018/12/10/《Refactoring》读书笔记（四）重新组织数据/" data-id="cjt5cp7k4000g2b991jbx3tcx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Books/">Books</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-《Refactoring》读书笔记（三）在对象之间搬移特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/04/《Refactoring》读书笔记（三）在对象之间搬移特性/" class="article-date">
  <time datetime="2018-12-04T05:39:35.000Z" itemprop="datePublished">2018-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书笔记/">读书笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/《Refactoring》读书笔记（三）在对象之间搬移特性/">《Refactoring》读书笔记（三）在对象之间搬移特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="第七章-在对象之间搬移特性"><a href="#第七章-在对象之间搬移特性" class="headerlink" title="第七章 在对象之间搬移特性"></a>第七章 在对象之间搬移特性</h1><h2 id="7-1-Move-Method（搬移函数）"><a href="#7-1-Move-Method（搬移函数）" class="headerlink" title="7.1 Move Method（搬移函数）"></a>7.1 Move Method（搬移函数）</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或者被后者调用。</p>
<p><strong>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。</strong></p>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>“搬移函数”是重构理论的支柱。通过这种手段，可以使系统中的类更简单，这些类最终也将更干净利落地实现系统交付的任务。</p>
<h2 id="7-2-Move-Field（搬移字段）"><a href="#7-2-Move-Field（搬移字段）" class="headerlink" title="7.2 Move Field（搬移字段）"></a>7.2 Move Field（搬移字段）</h2><h3 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h3><p>在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。</p>
<p><strong>在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段。</strong></p>
<h2 id="7-3-Extract-Class（提炼类）"><a href="#7-3-Extract-Class（提炼类）" class="headerlink" title="7.3 Extract Class（提炼类）"></a>7.3 Extract Class（提炼类）</h2><h3 id="概要-2"><a href="#概要-2" class="headerlink" title="概要"></a>概要</h3><p>某个类做了应该由两个类做的事。</p>
<p><strong>建立一个新类，将相关的字段和函数从旧类搬移到新类。</strong></p>
<h2 id="7-4-Inline-Class（将类内联化）"><a href="#7-4-Inline-Class（将类内联化）" class="headerlink" title="7.4 Inline Class（将类内联化）"></a>7.4 Inline Class（将类内联化）</h2><p>某个类没有做太多事情。</p>
<p><strong>将这个类的所有特性搬移到另一个类中，然后移除原类。</strong></p>
<h2 id="7-5-Hide-Delegate（隐藏“委托关系”）"><a href="#7-5-Hide-Delegate（隐藏“委托关系”）" class="headerlink" title="7.5 Hide Delegate（隐藏“委托关系”）"></a>7.5 Hide Delegate（隐藏“委托关系”）</h2><h3 id="概要-3"><a href="#概要-3" class="headerlink" title="概要"></a>概要</h3><p>客户通过一个委托类来调用另一个对象。</p>
<p><strong>在服务类上建立客户所需的所有函数，用以隐藏委托关系。</strong></p>
<h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3><p>即便将来发生委托关系上的变化，变化也将被限制在服务对象中，不会波及客户。</p>
<h2 id="7-6-Remove-Middle-Man（移除中间人）"><a href="#7-6-Remove-Middle-Man（移除中间人）" class="headerlink" title="7.6 Remove Middle Man（移除中间人）"></a>7.6 Remove Middle Man（移除中间人）</h2><h3 id="概要-4"><a href="#概要-4" class="headerlink" title="概要"></a>概要</h3><p>某个类做了过多的简单委托动作。</p>
<p><strong>让客户直接调用委托类。</strong></p>
<h3 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h3><p>6个月前恰如其分的封装，现今可能就显得笨拙。重构的意义就在于：你永远不必说对不起——只要把出问题的地方修补好就行了。</p>
<h2 id="7-7-Introduce-Foreign-Method（引入外加函数）"><a href="#7-7-Introduce-Foreign-Method（引入外加函数）" class="headerlink" title="7.7 Introduce Foreign Method（引入外加函数）"></a>7.7 Introduce Foreign Method（引入外加函数）</h2><h3 id="概要-5"><a href="#概要-5" class="headerlink" title="概要"></a>概要</h3><p>你需要为提供服务的类增加一个函数，但你无法修改这个类。</p>
<p><strong>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。</strong></p>
<h2 id="7-8-Introduce-Local-Extension（引入本地扩展）"><a href="#7-8-Introduce-Local-Extension（引入本地扩展）" class="headerlink" title="7.8 Introduce Local Extension（引入本地扩展）"></a>7.8 Introduce Local Extension（引入本地扩展）</h2><h3 id="概要-6"><a href="#概要-6" class="headerlink" title="概要"></a>概要</h3><p>你需要为服务类提供一些额外函数，但你无法修改这个类。</p>
<p><strong>建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://iCodeWoods.github.io/2018/12/04/《Refactoring》读书笔记（三）在对象之间搬移特性/" data-id="cjt5cp7jz000b2b99t430xv0l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Books/">Books</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-《Refactoring》读书笔记（二）重新组织函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/28/《Refactoring》读书笔记（二）重新组织函数/" class="article-date">
  <time datetime="2018-11-28T05:34:38.000Z" itemprop="datePublished">2018-11-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书笔记/">读书笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/28/《Refactoring》读书笔记（二）重新组织函数/">《Refactoring》读书笔记（二）重新组织函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="第六章-重新组织函数"><a href="#第六章-重新组织函数" class="headerlink" title="第六章 重新组织函数"></a>第六章 重新组织函数</h1><h2 id="6-1-Extract-Method（提炼函数）"><a href="#6-1-Extract-Method（提炼函数）" class="headerlink" title="6.1 Extract Method（提炼函数）"></a>6.1 Extract Method（提炼函数）</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>你有一段代码可以被组织在一起并独立出来。</p>
<p><strong>将这段代码放进一个独立函数中，并让函数名称解释该函数的用途。</strong></p>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>复用机会大，覆写更容易，使高层函数读起来就像一系列注释。</p>
<p>函数长度不是问题，关键在于函数名称和函数本体之间的语义距离。如果提炼可以强化代码的清晰度，那就去做，就算函数名称比提炼出来的代码还长也无所谓。</p>
<p>难点在于局部变量，包括传进源函数的参数和源函数所声明的临时变量。</p>
<p>可以先尝试运用 Replace Temp with Query（120）减少临时变量。如果仍困难重重，我就会动用 Replace Method with Method Object（135），这个重构手法不在乎代码中有多少临时变量，也不在乎你如何使用它们。</p>
<h2 id="6-2-Inline-Method（内联函数）"><a href="#6-2-Inline-Method（内联函数）" class="headerlink" title="6.2 Inline Method（内联函数）"></a>6.2 Inline Method（内联函数）</h2><h3 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h3><p>一个函数的本体与名称同样清楚易懂。</p>
<p><strong>在函数调用点插入函数本体，然后移除该函数。</strong></p>
<h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3><p>间接层有其价值，但不是所有间接层都有价值。</p>
<p>另一种需要使用 Inline Method（117）的情况是，你手上有一群组织不甚合理的函数。你可以将它们都内联到一个大型函数中，再从中提炼出组织合理的小型函数。Kent Beck 发现，实施 Replace Method with Method Object（135）之前先这么做， 往往可以获得不错的效果。</p>
<h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><ul>
<li>检查函数，确定它不具多态性（如果子类继承了这个函数，就不要将此函数内联，因为子类无法覆写一个根本不存在的函数。）</li>
<li>略</li>
</ul>
<p>难点：对于递归调用、多返回点、内联至另一个对象中而该对象并无提供访问函数……等等。如果遇到了这样的复杂情况，那么就不应该使用这个重构手法。</p>
<h2 id="6-3-Inline-Temp（内联临时变量）"><a href="#6-3-Inline-Temp（内联临时变量）" class="headerlink" title="6.3 Inline Temp（内联临时变量）"></a>6.3 Inline Temp（内联临时变量）</h2><h3 id="概要-2"><a href="#概要-2" class="headerlink" title="概要"></a>概要</h3><p>你有一个临时变量，只被一个简单表达式赋值一次，而它妨碍了其它重构手法。</p>
<p><strong>将所有对该变量的引用动作，替换为对它赋值的那个表达式本身。</strong></p>
<h3 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h3><p>Inline Temp（119）多半是作为 Replace Temp with Query（120）的一部分使用的，所以真正的动机出现在后者那儿。</p>
<h2 id="6-4-Replace-Temp-with-Query"><a href="#6-4-Replace-Temp-with-Query" class="headerlink" title="6.4 Replace Temp with Query"></a>6.4 Replace Temp with Query</h2><h3 id="概要-3"><a href="#概要-3" class="headerlink" title="概要"></a>概要</h3><p>你的程序以一个临时变量保存某一表达式的运算结果。</p>
<p><strong>将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可以被其它函数使用。</strong></p>
<h3 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h3><p>由于临时变量只在所属函数内可见，所以它们会<strong>驱使你写出更长的函数，因为只有这样你才能访问到需要的临时变量。</strong></p>
<h2 id="6-5-Introduce-Explaining-Variable（引入解释性变量）"><a href="#6-5-Introduce-Explaining-Variable（引入解释性变量）" class="headerlink" title="6.5 Introduce Explaining Variable（引入解释性变量）"></a>6.5 Introduce Explaining Variable（引入解释性变量）</h2><h3 id="概要-4"><a href="#概要-4" class="headerlink" title="概要"></a>概要</h3><p>你有一个复杂的表达式。</p>
<p><strong>将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。</strong></p>
<h2 id="6-6-Split-Temporary-Varibale（分解临时变量）"><a href="#6-6-Split-Temporary-Varibale（分解临时变量）" class="headerlink" title="6.6 Split Temporary Varibale（分解临时变量）"></a>6.6 Split Temporary Varibale（分解临时变量）</h2><h3 id="概要-5"><a href="#概要-5" class="headerlink" title="概要"></a>概要</h3><p>你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。</p>
<p><strong>针对每次赋值，创造一个独立、对应的临时变量。</strong></p>
<h3 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h3><p>同一个临时变量承担两件不同的事情，会令代码阅读者糊涂。</p>
<blockquote>
<p>我敢保证，这比吃苏格兰布丁强多了——你知道他们都在里面放了些什么东西吗？</p>
<p>（苏格兰布丁：haggis，一种苏格兰菜，把羊心等内脏装在羊胃里煮成。由于它被羊胃包成一个球体，因此可以像球一样踢来踢去。）</p>
</blockquote>
<h2 id="6-7-Rmove-Assignments-to-Prarmeters（移除对参数的赋值）"><a href="#6-7-Rmove-Assignments-to-Prarmeters（移除对参数的赋值）" class="headerlink" title="6.7 Rmove Assignments to Prarmeters（移除对参数的赋值）"></a>6.7 Rmove Assignments to Prarmeters（移除对参数的赋值）</h2><h3 id="概要-6"><a href="#概要-6" class="headerlink" title="概要"></a>概要</h3><p>代码对一个参数进行赋值。</p>
<p><strong>以一个临时变量取代该参数的位置。</strong></p>
<h2 id="6-8-Replace-Method-with-Method-Object（以函数对象取代函数）"><a href="#6-8-Replace-Method-with-Method-Object（以函数对象取代函数）" class="headerlink" title="6.8 Replace Method with Method Object（以函数对象取代函数）"></a>6.8 Replace Method with Method Object（以函数对象取代函数）</h2><h3 id="概要-7"><a href="#概要-7" class="headerlink" title="概要"></a>概要</h3><p>你有一个大型函数，其中对局部变量的使用使你无法采用 Extract Method（110）。</p>
<p><strong>将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。</strong></p>
<h2 id="6-9-Substitute-Algorithm（替换算法）"><a href="#6-9-Substitute-Algorithm（替换算法）" class="headerlink" title="6.9 Substitute Algorithm（替换算法）"></a>6.9 Substitute Algorithm（替换算法）</h2><h3 id="概要-8"><a href="#概要-8" class="headerlink" title="概要"></a>概要</h3><p>你想要把某个算法替换为另一个更清晰的算法。</p>
<p><strong>将函数本体替换为另一个算法。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://iCodeWoods.github.io/2018/11/28/《Refactoring》读书笔记（二）重新组织函数/" data-id="cjt5cp7k2000c2b99eimea22p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Books/">Books</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-《Refactoring》读书笔记（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/21/《Refactoring》读书笔记（一）/" class="article-date">
  <time datetime="2018-11-21T05:20:26.000Z" itemprop="datePublished">2018-11-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书笔记/">读书笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/21/《Refactoring》读书笔记（一）/">《Refactoring》读书笔记（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="第一章-重构，第一个案例"><a href="#第一章-重构，第一个案例" class="headerlink" title="第一章 重构，第一个案例"></a>第一章 重构，第一个案例</h1><blockquote>
<p>如果你发现自己需要为程序添加一个特效，而代码结构使你无法很方便地达成目的，那就先重构那个程序，使特性的添加比较容易进行，然后再添加特性。</p>
</blockquote>
<blockquote>
<p>重构前，先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验能力。</p>
</blockquote>
<blockquote>
<p>任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。</p>
</blockquote>
<p><strong>重构时最好小步前进，如此一来犯错的几率最小。</strong></p>
<p>（我司的重构一般都是对一个模块使用另一种模式如VIPER/MVP去写，所以都是直接重新写一个模块，然后两者做ABTest以确保无误。。。这种情况真是太难测试了。。。)</p>
<blockquote>
<p>这个例子给我们最大的启发是重构的节奏：测试、小修改、测试、小修改、测试、小修改。。。。。。正是这种节奏让重构得以快速而安全地前进。</p>
</blockquote>
<p>（Emmm。。。我司的方式好像不应该叫重构，而应该叫“重写”。。。）</p>
<h1 id="第二章-重构原则"><a href="#第二章-重构原则" class="headerlink" title="第二章 重构原则"></a>第二章 重构原则</h1><h2 id="何谓重构-what"><a href="#何谓重构-what" class="headerlink" title="何谓重构 what"></a>何谓重构 what</h2><blockquote>
<ul>
<li>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本</li>
<li>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构</li>
</ul>
</blockquote>
<h3 id="两顶帽子"><a href="#两顶帽子" class="headerlink" title="两顶帽子"></a>两顶帽子</h3><p>使用重构技术开发软件时，你把自己的时间分配给两种截然不同的行为：添加新功能，以及重构。</p>
<ul>
<li>添加新功能时，你不应该修改既有代码，只管添加新功能。通过测试（并让测试正常运行），你可以衡量自己的工作进度。</li>
<li>重构时你就不能再添加功能，只管改进程序结构。此时你不应该添加任何测试（除非发现有先前遗漏的东西），只在绝对必要（用以处理接口变化）时才修改测试。</li>
</ul>
<p>无论何时你都应该清楚自己戴的是哪一顶帽子。</p>
<h2 id="为何重构-why"><a href="#为何重构-why" class="headerlink" title="为何重构 why"></a>为何重构 why</h2><ul>
<li>重构改进软件设计。如果消除重复代码，就可以确定所有事物和行为在代码中只表述一次，这正是优秀设计的根本。</li>
<li>重构使软件更容易理解。早期重构是“擦掉窗户上的污垢，使你看得更远”。</li>
<li>重构帮助找到 bug。搞清楚程序结构的同时，也清楚了自己所做的一些假设，于是想不把 bug 揪出来都难。</li>
<li>重构提高编程速度。良好设计是维持软件开发速度的根本。</li>
</ul>
<h2 id="何时重构-when"><a href="#何时重构-when" class="headerlink" title="何时重构 when"></a>何时重构 when</h2><p>反对专门拨出时间进行重构。重构应该随时随地进行，不应该为重构而重构，之所以重构，是因为你想做别的什么事，而重构可以帮助你把那些事做好。</p>
<h3 id="三次法则"><a href="#三次法则" class="headerlink" title="三次法则"></a>三次法则</h3><p>第一次做某件事时只管去做；第二次做类似的事时会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。</p>
<blockquote>
<p>事不过三，三则重构。</p>
</blockquote>
<ul>
<li>添加功能时重构。</li>
<li>修补错误时重构。</li>
<li>复审代码时重构。</li>
</ul>
<p>间接层的价值：</p>
<ul>
<li>允许逻辑共享</li>
<li>分开解释意图和实现</li>
<li>隔离变化</li>
<li>封装条件逻辑</li>
</ul>
<h2 id="重构的难题"><a href="#重构的难题" class="headerlink" title="重构的难题"></a>重构的难题</h2><ul>
<li>数据库</li>
<li>修改接口</li>
<li>难以通过重构手法完成的设计改动</li>
<li>何时不该重构</li>
</ul>
<h2 id="重构与设计"><a href="#重构与设计" class="headerlink" title="重构与设计"></a>重构与设计</h2><p>重构肩负一项特殊使命：它和设计彼此互补。</p>
<p>重构可以带来更简单的设计，同时又不损失灵活性，这也降低了设计过程的难度。</p>
<blockquote>
<p>哪怕你完全了解系统，也请实际度量它的性能，不要臆测。臆测会让你学到一些东西，但十有八九你是错的。</p>
</blockquote>
<h2 id="重构与性能"><a href="#重构与性能" class="headerlink" title="重构与性能"></a>重构与性能</h2><p>除了对性能有严格要求的实时系统，其他任何情况下“编写快速软件”的秘诀就是：首先写出可调的软件，然后调整它以求获得足够速度。</p>
<h2 id="重构起源何处"><a href="#重构起源何处" class="headerlink" title="重构起源何处"></a>重构起源何处</h2><h1 id="第三章-代码的坏味道"><a href="#第三章-代码的坏味道" class="headerlink" title="第三章 代码的坏味道"></a>第三章 代码的坏味道</h1><blockquote>
<p>P.S. 第三章内容比较多，将单独拎出来一节</p>
</blockquote>
<h1 id="第四章-构筑测试体系"><a href="#第四章-构筑测试体系" class="headerlink" title="第四章 构筑测试体系"></a>第四章 构筑测试体系</h1><h2 id="4-1-自测试代码的价值"><a href="#4-1-自测试代码的价值" class="headerlink" title="4.1 自测试代码的价值"></a>4.1 自测试代码的价值</h2><blockquote>
<p>确保所有测试都完全自动化，让它们检查自己的测试结果。</p>
<p>一套测试就是一个强大的bug侦测器，能够大大缩减查找bug所需要的时间。</p>
</blockquote>
<h2 id="4-2-JUnit-测试框架"><a href="#4-2-JUnit-测试框架" class="headerlink" title="4.2 JUnit 测试框架"></a>4.2 JUnit 测试框架</h2><blockquote>
<p>频繁地运行测试。每次编译请把测试也考虑进去——每天至少执行每个测试一次。</p>
</blockquote>
<h3 id="单元测试（Unit-Test）和功能测试（Functional-Test）"><a href="#单元测试（Unit-Test）和功能测试（Functional-Test）" class="headerlink" title="单元测试（Unit Test）和功能测试（Functional Test）"></a>单元测试（Unit Test）和功能测试（Functional Test）</h3><blockquote>
<p>每当你收到bug报告，请先写一个单元测试来暴露这个bug。</p>
</blockquote>
<h2 id="4-3-添加更多测试"><a href="#4-3-添加更多测试" class="headerlink" title="4.3 添加更多测试"></a>4.3 添加更多测试</h2><blockquote>
<p>编写未臻完善的测试并实际运行，好过对完美测试的无尽等待。</p>
<p>考虑可能出错的边界条件，把测试火力集中在那儿。</p>
<p>当事情被认为应该会出错时，别忘了检查是否抛出了预期的异常。</p>
<p>不要因为测试无法捕捉到所有 bug 就不写测试，因为测试的确可以捕捉到大多数 bug。</p>
</blockquote>
<h1 id="第五章-重构列表"><a href="#第五章-重构列表" class="headerlink" title="第五章 重构列表"></a>第五章 重构列表</h1><h2 id="5-1-重构的记录格式"><a href="#5-1-重构的记录格式" class="headerlink" title="5.1 重构的记录格式"></a>5.1 重构的记录格式</h2><ul>
<li>名称（name）</li>
<li>概要（summary）：适用场景，以及它所做的事情。</li>
<li>动机（motivation）：为什么需要这个重构，以及什么情况下不该使用这个重构。</li>
<li>做法（mechanics）</li>
<li>范例（examples）</li>
</ul>
<h2 id="5-2-寻找引用点"><a href="#5-2-寻找引用点" class="headerlink" title="5.2 寻找引用点"></a>5.2 寻找引用点</h2><h2 id="5-3-这些重构手法有多成熟"><a href="#5-3-这些重构手法有多成熟" class="headerlink" title="5.3 这些重构手法有多成熟"></a>5.3 这些重构手法有多成熟</h2><p>设计模式为重构行为提供了目标。设计模式和重构之间有着一种与生俱来的关系。模式是你希望到达的目标，重构则是到达之路。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://iCodeWoods.github.io/2018/11/21/《Refactoring》读书笔记（一）/" data-id="cjt5cp7jw00082b99ftfmpm59" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Books/">Books</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-《浪潮之巅》读书笔记（二）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/30/《浪潮之巅》读书笔记（二）/" class="article-date">
  <time datetime="2018-10-30T09:59:20.000Z" itemprop="datePublished">2018-10-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书笔记/">读书笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/30/《浪潮之巅》读书笔记（二）/">《浪潮之巅》读书笔记（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第四章-计算机工业的生态链"><a href="#第四章-计算机工业的生态链" class="headerlink" title="第四章 计算机工业的生态链"></a>第四章 计算机工业的生态链</h1><h2 id="计算机行业的发展规律"><a href="#计算机行业的发展规律" class="headerlink" title="计算机行业的发展规律"></a>计算机行业的发展规律</h2><ul>
<li>摩尔定律</li>
<li>安迪•比尔定律</li>
<li>反摩尔定律</li>
</ul>
<h3 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h3><p>摩尔定律主导着IT行业的发展。</p>
<ul>
<li>首先，为了不断提升芯片性能，IT公司必须在比较短的时间内完成下一代产品的开发。</li>
<li>其次，由于有了强有力的硬件支持，以前想都不敢想的应用会不断涌现。</li>
<li>第三，摩尔定律使得各个公司现在的研发必须针对多年后的市场。在Google内部，每一次基础架构(Infrastructure)的升级，都要按照目前计算能力和存储量的10倍来设计，因为达到那个水平，不过是三四年的时间，这在传统行业是无法想象的。</li>
</ul>
<p>在世界经济的前五大行业，即金融、IT、医疗和制造、能源及日用消费品，只有IT一个行业能够以持续翻番的速度进步。</p>
<h3 id="安迪•比尔定律"><a href="#安迪•比尔定律" class="headerlink" title="安迪•比尔定律"></a>安迪•比尔定律</h3><p>比尔要拿走安迪所给的（What Andy gives，Bill takes away）</p>
<p>（安迪是原英特尔CEO安迪•格鲁夫）</p>
<p>没有了看似魔鬼的“比尔”，“安迪”这个天使也就不复存在了。</p>
<h3 id="反摩尔定律"><a href="#反摩尔定律" class="headerlink" title="反摩尔定律"></a>反摩尔定律</h3><p>一个IT公司如果今天和18个月前卖掉同样多的、同样的产品，它的营业额就要降一半。</p>
<p>事实上，反摩尔定律积极的一面重要，它促成科技领域质的进步，并为新兴公司提供生存和发展的可能。</p>
<p>每一种技术，过不了多少年，量变的潜力就会被挖掘光，这时就必须要有革命性的创造发明诞生。</p>
<p>任何一家技术发展赶不上摩尔定律要求的公司，用不了几年就会被淘汰。</p>
<p>IT行业是一个高速发展的行业；在这个行业中发展，犹如逆水行舟，不进则退。</p>
<h1 id="第五章-奔腾的芯-英特尔公司"><a href="#第五章-奔腾的芯-英特尔公司" class="headerlink" title="第五章 奔腾的芯 英特尔公司"></a>第五章 奔腾的芯 英特尔公司</h1><p>那里之所以叫硅谷，并不是因为它生产硅，而是因为在这里有很多使用硅的半导体公司，包括全球最大的半导体公司英特尔。</p>
<p>IT业者甚至将整个PC时代称为WinTel时代。</p>
<p>它给了每台PC一颗奔腾的芯。</p>
<p>摩尔等八人创办了仙童（Fairchild）半导体公司。<br>这八个人在IT历史上被称为“八叛徒”</p>
<p>（为啥叫“八叛徒”？）</p>
<p>英特尔起步的上个世纪80年代，恰恰是日本经济达到巅峰的黄金10年。当时日本股市的总市值占了全世界的一半，日本东京附近的房地产总值相当于半个美国的房市总值。（卧槽，这么🐂的吗😨）</p>
<h2 id="英特尔与摩托罗拉之战"><a href="#英特尔与摩托罗拉之战" class="headerlink" title="英特尔与摩托罗拉之战"></a>英特尔与摩托罗拉之战</h2><ul>
<li>首先，这是两家不同时代的公司。</li>
</ul>
<p>摩托罗拉的员工在工资和福利上待遇不错，但是公司和员工，基本上还是传统的雇佣关系，公司内部管理层级较多，大部分员工基本上没有多少股票期权。因此，公司的业绩和员工的利益关系不大。英特尔公司则是一家典型的硅谷公司。每个员工的工作强度比摩托罗拉要大很多，但是每个人平均的股票期权也多很多。硅谷几个比较好的学区，不少房子都被英特尔公司的早期员工买走了，而这些房子靠工资是一辈子也买不起的。（太真实了［捂脸］）</p>
<p>（以前没毕业的时候，我一直以为创业公司的股票期权没什么卵用，不如多发点工资实在。随着年龄的增长，现在感觉股票期权其实还是很重要的，只拿死工资的话永远就只是那么一点。真是不同时期感受不一样啊。）</p>
<p>几年前，美国历史频道在节目中评论了中日甲午战争，虽然双方武器相差不多，战争的结果不会有任何悬念，因为处在专制的农业时代后期的军队很难打赢一支新兴的工业化国家的军队。英特尔和摩托罗拉之间的竞争也是如此。</p>
<ul>
<li>其次，两家公司的统帅水平相去甚远。</li>
</ul>
<p>摩托罗拉公司由高尔文兄弟创办，上个世纪60年代传到了儿子手里，上个世纪八九十年代传到了孙子手里，是个典型的家族公司。俗话说“富不过三代”，这句话果然应验在高尔文家族上，三代人可以说是一代不如一代。（为什么会富不过三代呢？）</p>
<ul>
<li>最后，也是非常重要的，英特尔比摩托罗拉更专注。</li>
</ul>
<p>在业务上，半导体只是摩托罗拉的一个部门，而处理器又只是其半导体部门的一项业务，对于英特尔来讲处理器芯片却是全部。因此，摩托罗拉即使完全退出计算机处理器市场也不过是损失一血地盘，而英特尔一旦失败，则会面临灭顶之灾。<br>（那么到底是只专注地做一件事好，还是多方面发展好？）</p>
<p>这就像一把散线和一股绳，散线很容易被绳扯断。</p>
<p>多年前，很多人问我雅虎有没有可能在搜索领域赶上Google，我明确地回答：没有，因为雅虎不可能专注在这一个领域。（谷歌也不只是专注在这一个领域吧🤔️）</p>
<p>英特尔无疑是过去几十年信息革命大潮中最成功的公司之一，但是今后除非找到新的成长点，否则它也会随着个人电脑时代的过去而进入平和的中老年期。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://iCodeWoods.github.io/2018/10/30/《浪潮之巅》读书笔记（二）/" data-id="cjt5cp7k8000n2b9925wy2z9h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Books/">Books</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-《浪潮之巅》读书笔记（一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/15/《浪潮之巅》读书笔记（一）/" class="article-date">
  <time datetime="2018-10-15T03:31:24.000Z" itemprop="datePublished">2018-10-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书笔记/">读书笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/15/《浪潮之巅》读书笔记（一）/">《浪潮之巅》读书笔记（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第二章-蓝色巨人-IBM公司"><a href="#第二章-蓝色巨人-IBM公司" class="headerlink" title="第二章 蓝色巨人 IBM公司"></a>第二章 蓝色巨人 IBM公司</h1><ul>
<li>当今工业界最大的实验室</li>
<li>世界第一的专利申请大户</li>
<li>全球最大的RISC服务器制造商</li>
</ul>
<p>IBM能成为科技界的常青树，要归功于它的二字秘诀——保守。毫无疑问，保守让IBM失去了无数次发展机会，但是也让它能专注于做最重要的事，并因此立于不败之地。</p>
<p>任何经济危机都是这样，会淘汰掉经营不善和泡沫成分大的公司，为生存下来的公司提供更好的发展空间。（原来经济危机还有好处啊）</p>
<p>参与制造著名的勃朗宁自动步枪和M1冲锋枪，间接地参与了研制原子弹的曼哈顿计划。（这可太牛皮了）</p>
<p>第二次世界大战。。。电子技术革命的浪潮。</p>
<p>恩格斯说过，社会的需求对科技进步的作用要超过10所大学。计算机就是在这种背景下发明出来的。（社会需求确实很重要）</p>
<p>生产出IBM System 360为止，IBM在计算机研制和生产上的总投入高达50亿美元，相当于整个马歇尔计划的三分之一。</p>
<p>马歇尔计划，又称为欧洲复兴计划，是二战结束后美国对被战争破坏的西欧各国进行经济援助、协助重建的计划，对欧洲国家的发展和世界政治格局产生了深远的影响。（美国竟然这么好心？难道别有所图？）</p>
<p>如果要对计算机工业的历史划分阶段，那么，1976年可以作为一个分水岭。这一年，没有读完大学的史蒂夫•乔布斯和沃兹尼亚克在车库里整出了世界上第一台可以商业化的个人电脑Apple I。在硅谷，很多公司创业时因为资金有限，常常租用租金低廉的民房甚至车库来办公，这几乎是硅谷特有的现象，被称为车库文化，苹果起家时也不例外。</p>
<p>对于个人电脑，IBM观望了几年。这对IBM这样一家大公司来讲是非常有必要的。我们前面讲过，IBM成功的秘诀是保守，它基本上是不见兔子不撒鹰。如果苹果公司失败了，IBM无需做任何事情。要是苹果公司成功了，IBM依靠它强大的技术储备完全可以后发制人。（这也是我常担心的一点，虽然我其实完全没资格担心😅）</p>
<p>2005年IBM将个人电脑业务卖给了中国的联想公司，IBM彻底退出了个人电脑的舞台。</p>
<p>如果不是反垄断的限制，IBM可以阻止这些公司使用自己的技术进入市场，或者直接收购其中的佼佼者。但是，有了反垄断的限制后，它对比也只能睁一只眼，闭一只眼。一方面，自己不愿意下功夫做PC，另一方面无法阻止别人做PC，IBM只好看着康柏（现在是惠普公司的一部分）、戴尔等公司做大了。（反垄断对于我们平民百姓来说应该是好事吧？）</p>
<p>硅谷一位最成功的CEO讲，凡是和微软合作的公司，最后都没有好结果。IBM也许是其中第一个吃亏的。</p>
<p>郭士纳原来是一家食品公司的总裁。</p>
<p>他也是做（芯）片的，但做的是薯片（He also made chips, but photo chips.）。这句原先是嘲笑他的话，以后成为他传奇的象征。没有高科技公司背景的郭士纳在世界上最大的高科技公司里创造了一个奇迹。</p>
<p>郭士纳将IBM比喻成大象，跟不上竞争对手的步伐。</p>
<h1 id="第三章-“水果”公司的复兴-乔布斯和苹果公司"><a href="#第三章-“水果”公司的复兴-乔布斯和苹果公司" class="headerlink" title="第三章 “水果”公司的复兴 乔布斯和苹果公司"></a>第三章 “水果”公司的复兴 乔布斯和苹果公司</h1><p>生母是一名未婚在校生，因为自己无法在读书的同时带孩子，她决定将乔布斯送给别人收养。她非常希望为乔布斯找一户有大学学历的人家。乔布斯的养父母许诺日后一定送他上大学，乔布斯的生母才答应了。（父母对孩子的未来太重要了）</p>
<p>大学半年退学，但是没有离开学校，而是开始在学校旁听他感兴趣的、将来可能对他有用的课。乔布斯没有收入，就睡在同学宿舍地板上，同时靠捡玻璃瓶、可乐罐挣点小钱糊口。</p>
<p>1983年，乔布斯说服了百事可乐公司的总裁约翰•斯卡利到苹果出任CEO。1985年，乔布斯被踢出他自己创办的苹果公司，那一年，乔布斯刚满30岁。乔布斯一气之下，卖掉了他所持有的苹果公司全部股票。（乔布斯最后还保留了一股，以便可以收到公司的财报）</p>
<p>后来苹果公司开始亏损，斯卡利不得不下台。斯卡利的两个继任者也是回天无力。苹果被微软打得一塌糊涂，差点被卖给IBM和太阳公司，但这两家公司谁也看不上苹果这个市场不断萎缩的个人电脑制造商。如果卖成了，今天就没有iPod和iPhone了。</p>
<p>1996年，苹果收购NeXT及其NeXTSTEP操作系统，也将乔布斯请回了苹果，该收购于1997年初完成。在美国，董事会赶走一个公司创始人的情况虽然不常见，但还是发生过的。然而，再把那个被赶走的创始人请回来执掌公司，不仅以前没听说过，以后也很难再有。</p>
<p>2003年10月，乔布斯患上癌症。</p>
<p>2011年10月5日，56岁的传奇人物乔布斯走完了他极富戏剧性的人生历程。他一生战胜了无数的对手，但是和所有人一样，他最终输给了死神。</p>
<p>乔布斯送给年轻人两句话：Stay Hungry，Stay Foolish.</p>
<p>在每一次技术革命中，新技术必须比老的技术有数量级的进步才能站住脚。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://iCodeWoods.github.io/2018/10/15/《浪潮之巅》读书笔记（一）/" data-id="cjt5cp7k5000i2b99fikbbu2z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Books/">Books</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS 动态化的故事" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/24/iOS 动态化的故事/" class="article-date">
  <time datetime="2018-05-24T02:46:50.000Z" itemprop="datePublished">2018-05-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/24/iOS 动态化的故事/">iOS 动态化的故事</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>本文转载自：<a href="http://blog.cnbang.net/tech/3286/" target="_blank" rel="noopener">bang’s blog</a></strong></p>
<p>&nbsp;</p>
<p>今天聊聊 iOS 动态化的故事。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在开发模式上，web 的方式是比较先进的，有各种优点，包括跨平台/UI开发效率高，最重要的是可以时刻保证用户看到的程序是最新的，没有版本概念，整个系统时刻保持在掌握之中，而客户端开发模式相对 web 开发是一种倒退，客户端做不到这样的动态化，无法随时更新，目前一个客户端程序要更新成本是很高的，需要发布版本，也无法保证所有人都能更新到这个版本，这是最大的弱点，也是非常大的一块需求。</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>为什么会有这种倒退，最主要原因是：苹果引领的体验优先规则。</p>
<p>在 iPhone 出现之前大家并不太在意一个软件的动画体验，一个 web 应用是很少有动画的，点一个按钮，一整块内容直接刷新，再点个链接整个页面变白刷新，PC上网页滚动都是一格格滚动的，而不是现在手机上那种顺滑流畅的滚动，PC客户端软件也一样，大家都觉得没什么问题，用得挺好，但苹果改变了这种情况，iPhone 刚推出时页面间切换的动画，60fps 的丝滑滚动，点击的即时响应，微软的人都惊呼是黑魔法，让人用了就上瘾，再也回不去，而 web 的方式还不足以像原生客户端那样支持这样的流畅性，做不到好的体验，无法被人接受，开发上优势再多也无法干过客户端，参考 facebook 初期用 web 技术构建 app 的惨状，没办法，服了苹果，大家只能按照苹果的方式干，做原生客户端。</p>
<p>当然这里还有手机环境网络不稳定，流量费贵的原因，但这些都可以在技术上通过缓存解决，最主要还是体验问题。</p>
<p>那发展到今天，这个体验问题解决了没有呢？没有，即使发展到今天手机性能已上天，但 web 做出来的东西体验仍然跟客户端有差别，大家也已经习惯了 APP 的方式，也被流畅的 APP 惯坏。现在 APP 里也有不少功能是 web实现，但大家都知道这是牺牲了一些性能体验去换取开发和发布效率，只是一种权衡。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>那这个问题怎么解决呢，现在业界有两种方案。</p>
<h2 id="1-优化-web-性能"><a href="#1-优化-web-性能" class="headerlink" title="1.优化 web 性能"></a>1.优化 web 性能</h2><p>既然用 web 方式开发的劣势只是性能体验跟不上，那就优化性能吧。web 性能瓶颈在哪里？在那个有悠久历史的 webkit 引擎，它有各种历史问题，要改进它并不容易。我们要的是 web 的开发和发布方式，不需要 web 的全部，那能不能重新实现一个渲染引擎呢，这个引擎可以针对原生客户端优化，不需要兼容繁杂的 web 标准，不跟 web 那些历史问题扯上关系，于是就有了 React Native 和 Weex 这种方案，web 的方式开发，原生的方式渲染，拥有 web 优秀的开发和发布方式，又有不错的性能体验，看起来很完美，很有前途的方案。</p>
<p>一个方案能不能推广开让大家都使用，主要看成本和收益。目前 React Native 和 Weex 等这些方案的接入成本是很高的，一是它们本身就是大型框架，学习成本高，后期维护成本以及团队学习成本同样高。二是它们还不够成熟，还在继续填坑中，使用的过程可能要一起去填坑。收益上也不够理想，就目前状况它们能代替的是那些本来用 H5 实现的模块，换成这种方式实现后性能体验会更好，但也不能保证像原生那样好，很多场景需要深入框架进行优化。整个 APP 都使用这种方案构建还不靠谱，部分使用又无法使整个 APP 保持动态化，总体上来说收益也没有达到有绝对优势的程度，成本高收益低，推广起来会比较困难，还需期待其继续发展。</p>
<h2 id="2-原生动态化"><a href="#2-原生动态化" class="headerlink" title="2.原生动态化"></a>2.原生动态化</h2><p>另一种是方案是，我可以放弃用 web 的开发方式，放弃 web 跨平台/UI开发简单的优越性，我想继续用原生的方式开发这个APP，但又希望这个 APP 随时可以更新，让程序时刻在自己掌握中，出了问题可以快速修复，还想要可以随时更新版本快速迭代，可以不？完全可以，用动态库就行了。</p>
<h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>技术上要在 iOS 上做到原生动态化比 Android 更容易，iOS 开发语言 Objective-C 天生动态，运行时都能随意替换方法，运行时加载动态库又是项很老的技术，只要我把增量的代码和资源打包到一个 framework 里，动态下发运行时加载，修 bug，加功能都不在话下，性能完全无损，这件事就结束了。</p>
<p>但是呢。苹果把加载动态库的功能给封了，动态库必须跟随安装包一起签名才能被加载，无法通过别的途径签名后再下发。</p>
<p>为什么这么做呢，这又涉及到苹果另一个创举：审核模式（苹果的创举之多令人发指）。一个软件，要在一个平台上发布，需要先通过这个平台的人工审核，这个好像在苹果之前没见过有别人这样做过，windows 不用，mac 不用，各种 unix 不用，web 也不用，苹果为了对自己的平台有绝对控制权，搞了这样一个东西，审核模式就跟动态化冲突了，如果我一个 APP 可以不经过审核不断下发 framework 添加修改功能， 还需要苹果审核做什么？</p>
<p>因为这种限制，没法用最方便的方式进行动态更新了，整个 APP 发出去后就不受控制，有什么严重 bug，需要添加什么功能，都乖乖打个包提交给苹果审核，再等用户慢慢更新，对于急性子的中国人来说，这种事难以容忍。</p>
<h3 id="绕道"><a href="#绕道" class="headerlink" title="绕道"></a>绕道</h3><p>苹果把动态库这扇门关了，我们可以绕个道从另一个门进，动态加功能可以缓缓，大家需求还不那么迫切，但修 bug 的需求就很急，很多公司 APP 的 crash 率是 KPI 来着，看着线上 crash 不断增多又毫无办法是很不爽的事，于是有了 waxPatch 和 JSPatch 这种方案，曲线救国。</p>
<p>JSPatch 把 OC 手动翻译成 JS，在运行时通过 OC 的动态特性去调用和替换 OC 方法，实时修复 bug。修 bug 这个需求基本是满足了，虽然小绕了下道，但成本还是很低的，引擎本身也很小很轻量，接入对 APP 不会有任何负面影响，在关键时刻又可以帮大忙，成本低收益高，于是很容易推广开。</p>
<p>人欲望是无穷的，技术宅的折腾是无止境的，JSPatch 满足了修 bug 的需求，但还是无法满足动态化的全部需求，最大的缺点在于需要手写 JS，虽然已经有转换器辅助，但还没做到100%准确，用来修 bug 还好，用来添加功能的话学习成本和开发效率还不够。</p>
<p>于是有了滴滴的 DynamicCocoa 这种方案，绕了一个更大的道，从编译阶段入手，通过 clang 把 OC 代码编译成自己定制的 JS 格式，再动态下发去执行，做到原生开发，动态运行，主打动态添加功能，当然顺便把修 bug 也给支持了。手机 QQ 内部也有一个类似的方案，不过更进一步，他们通过 clang 把 OC 代码编译成自己定制的字节码动态下发，然后开发一个虚拟机去执行（惊呆了），同样实现了原生开发，动态运行，都是 NB 得很的方案。只要底层处理做得足够好，也是个成本低收益高的方案，不过目前都还没开源，还没能看到实际效果和 NB 的源码，挺期待。</p>
<h3 id="审核"><a href="#审核" class="headerlink" title="审核"></a>审核</h3><p>这种方案有没有什么问题呢，问题在对于苹果审核比较尴尬。这种方案做到极致后(所有OC/C语法都支持)，实际上是绕道实现了动态加载 framework 的全部功能，开发体验还是一致的，如果苹果同意这种方案，那相当于允许加载动态库，那还不如直接把门开了，让大家直接用动态库去做这个事情，用动态库还能在签名时禁止使用私有 API，用这种编译成脚本/字节码下发的方案可就禁止不了了。</p>
<p>这跟 JSPatch 还不太一样，JSPatch 虽然我也想推广动态添加功能的用法，但因为开发体验问题大部分还是用于修 bug，苹果审核对 JSPatch 开始也是有一些拒绝案例，后来估计看到大家只是用它来修 bug 和 crash，提升 APP 的质量，就默许了。但 DynamicCocoa 和手Q的方案一开始目标和效果就是跟加载动态库对齐，大规模推广后苹果会怎么看就不知道了。</p>
<p>我觉得苹果现在的审核方式挺有问题的，有多少APP是审核时用一套，审核通过后又通过后台一些开关把不符合规则的一些功能开放出来？只要能连上网，就有N种方式修改 APP 里的功能，苹果完全拦不住。个人认为审核方式应该改为只在发布新 APP 时审核，发布后允许动态下发代码更新，版本更新也不需要重新审核，而是通过举报和抽查的方式去审核已上线的 APP，这样既能顾及开发效率，方便开发者快速迭代做出更好的 APP，也更能确保审核效果，只是实施起来没有现在简单粗暴。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>故事讲到这里已经差不多了，再多说一点，有个让我觉得很奇怪的问题，就是国外开发者只热衷于使用第一种方案解决问题，也就是使用web技术，用 React Native / NativeScript 的方式去做这个事情，对第二种方案很冷淡，包括 iOS Android 都是，原生热更新只在国内火，国外根本不感冒，国外有个 rollout 热更新平台也不温不火，为什么呢？是国外用户更守规则，或是用户对线上 bug 容忍度高，开发者对线上 bug 并不那么着急？还是 Android 被 Google Play 卡死断了这念想，iOS JSPatch 之类的方案推广不利？缺少国外一线开发者的支持，让系统原生支持动态化就比较困难了。</p>
<p>个人认为由系统支持动态化（允许加载动态库）在当前环境下是最好的，兼顾开发效率和 APP 体验，虽然不能跨平台，但也还能接受，可惜这个主动权掌握在苹果手上，开发者无能为力，才会出现这么多强行绕道突破的方案。web 的方式可能是未来，但目前适用范围有限，接下来怎么发展，拭目以待吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://iCodeWoods.github.io/2018/05/24/iOS 动态化的故事/" data-id="cjt5cp7kt001v2b99axpphjl9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JSPatch/">JSPatch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动态化/">动态化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Bash学习之——数据流重导向" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/08/Bash学习之——数据流重导向/" class="article-date">
  <time datetime="2018-03-08T07:16:05.000Z" itemprop="datePublished">2018-03-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/脚本/">脚本</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/08/Bash学习之——数据流重导向/">Bash学习之——数据流重导向</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="stdout、stderr、-dev-null"><a href="#stdout、stderr、-dev-null" class="headerlink" title="stdout、stderr、/dev/null"></a>stdout、stderr、/dev/null</h2><ul>
<li>标准输入　　  (stdin)：代码为 0 ，使用 &lt; 或 &lt;&lt; ；</li>
<li>标准输出　 　(stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ；</li>
<li>标准错误输出 (stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ；</li>
</ul>
<h4 id="覆盖与累加"><a href="#覆盖与累加" class="headerlink" title="覆盖与累加"></a>覆盖与累加</h4><ul>
<li>1&gt; ：以覆盖的方法将『正确的数据』输出到指定的文件或装置上；</li>
<li>1&gt;&gt;：以累加的方法将『正确的数据』输出到指定的文件或装置上；</li>
<li>2&gt; ：以覆盖的方法将『错误的数据』输出到指定的文件或装置上；</li>
<li>2&gt;&gt;：以累加的方法将『错误的数据』输出到指定的文件或装置上；</li>
</ul>
<p>例：将 stdout 与 stderr 分别存入不同的文件中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -name .bashrc &gt; list_right 2&gt; list_error</span><br></pre></td></tr></table></figure></p>
<h4 id="dev-null-垃圾桶黑洞装置与特殊写法"><a href="#dev-null-垃圾桶黑洞装置与特殊写法" class="headerlink" title="/dev/null 垃圾桶黑洞装置与特殊写法"></a>/dev/null 垃圾桶黑洞装置与特殊写法</h4><p>如果我知道错误信息会发生，所以要将错误信息忽略掉而不显示或储存呢？黑洞装置 /dev/null 可以吃掉任何导向这个装置的信息喔！</p>
<p>将错误的数据丢弃，屏幕上显示正确的数据<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@www ~]$ find /home -name .bashrc 2&gt; /dev/null</span><br><span class="line">/home/dmtsai/.bashrc  &lt;==只有 stdout 会显示到屏幕上， stderr 被丢弃了</span><br></pre></td></tr></table></figure></p>
<p>再想象一下，如果我要将正确与错误数据通通写入同一个文件去呢？这个时候就得要使用特殊的写法了！ </p>
<p>我们同样用底下的案例来说明：</p>
<p>将命令的数据全部写入名为 list 的文件中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@www ~]$ find /home -name .bashrc &gt; list 2&gt; list  &lt;==错误</span><br><span class="line">[dmtsai@www ~]$ find /home -name .bashrc &gt; list 2&gt;&amp;1     &lt;==正确</span><br><span class="line">[dmtsai@www ~]$ find /home -name .bashrc &amp;&gt; list         &lt;==正确</span><br></pre></td></tr></table></figure></p>
<h4 id="standard-input-：-lt-与-lt-lt"><a href="#standard-input-：-lt-与-lt-lt" class="headerlink" title="standard input ： &lt; 与 &lt;&lt;"></a>standard input ： &lt; 与 &lt;&lt;</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">范例六：利用 cat 命令来创建一个文件的简单流程</span><br><span class="line">[root@www ~]<span class="comment"># cat &gt; catfile</span></span><br><span class="line">testing</span><br><span class="line">cat file <span class="built_in">test</span></span><br><span class="line">&lt;==这里按下 [ctrl]+d 来离开</span><br><span class="line">[root@www ~]<span class="comment"># cat catfile</span></span><br><span class="line">testing</span><br><span class="line">cat file <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">范例七：用 stdin 取代键盘的输入以创建新文件的简单流程</span><br><span class="line">[root@www ~]<span class="comment"># cat &gt; catfile &lt; ~/.bashrc</span></span><br><span class="line">[root@www ~]<span class="comment"># ll catfile ~/.bashrc</span></span><br><span class="line">-rw-r--r-- 1 root root 194 Sep 26 13:36 /root/.bashrc</span><br><span class="line">-rw-r--r-- 1 root root 194 Feb  6 18:29 catfile</span><br><span class="line"><span class="comment"># 注意看，这两个文件的大小会一模一样！几乎像是使用 cp 来复制一般！</span></span><br></pre></td></tr></table></figure>
<p>理解 &lt; 之后，再来则是怪可怕的 &lt;&lt; 这个连续两个小于的符号了。 他代表的是『结束的输入字符』的意思！举例来讲：『我要用 cat 直接将输入的信息输出到 catfile 中， 且当由键盘输入 eof 时，该次输入就结束』，那我可以这样做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># cat &gt; catfile &lt;&lt; "eof"</span></span><br><span class="line">&gt; This is a <span class="built_in">test</span>.</span><br><span class="line">&gt; OK now stop</span><br><span class="line">&gt; eof  &lt;==输入这关键词，立刻就结束而不需要输入 [ctrl]+d</span><br><span class="line">[root@www ~]<span class="comment"># cat catfile</span></span><br><span class="line">This is a <span class="built_in">test</span>.</span><br><span class="line">OK now stop     &lt;==只有这两行，不会存在关键词那一行！</span><br></pre></td></tr></table></figure></p>
<h2 id="命令运行的判断依据：-amp-amp"><a href="#命令运行的判断依据：-amp-amp" class="headerlink" title="命令运行的判断依据： ; , &amp;&amp;, ||"></a>命令运行的判断依据： ; , &amp;&amp;, ||</h2><p><img src="/2018/03/08/Bash学习之——数据流重导向/bash1.png" alt="&amp;&amp;与||"></p>
<p>例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不清楚 /tmp/abc 是否存在，但就是要创建 /tmp/abc/hehe 文件</span><br><span class="line">[root@www ~]<span class="comment"># ls /tmp/abc || mkdir /tmp/abc &amp;&amp; touch /tmp/abc/hehe</span></span><br></pre></td></tr></table></figure></p>
<p>由于Linux 底下的命令都是由左往右运行的，所以范例三有几种结果我们来分析一下：</p>
<ul>
<li>若 /tmp/abc 不存在故回传 $?≠0，则 (2)因为 || 遇到非为 0 的 $? 故开始 mkdir /tmp/abc，由于 mkdir /tmp/abc 会成功进行，所以回传 $?=0 (3)因为 &amp;&amp; 遇到 $?=0 故会运行 touch /tmp/abc/hehe，最终 hehe 就被创建了；</li>
<li>若 /tmp/abc 存在故回传 $?=0，则 (2)因为 || 遇到 0 的 $? 不会进行，此时 $?=0 继续向后传，故 (3)因为 &amp;&amp; 遇到 $?=0 就开始创建 /tmp/abc/hehe 了！最终 /tmp/abc/hehe 被创建起来。</li>
</ul>
<p><img src="/2018/03/08/Bash学习之——数据流重导向/bash2.png" alt="流程"></p>
<p>例题：<br>以 ls 测试 /tmp/vbirding 是否存在，若存在则显示 “exist” ，若不存在，则显示 “not exist”！<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /tmp/vbirding &amp;&amp; <span class="built_in">echo</span> <span class="string">"exist"</span> || <span class="built_in">echo</span> <span class="string">"not exist"</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://iCodeWoods.github.io/2018/03/08/Bash学习之——数据流重导向/" data-id="cjt5cp7jq00062b9948c2hqu2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Bash/">Bash</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/脚本/">脚本</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂/">杂</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/脚本/">脚本</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bash/">Bash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Books/">Books</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSPatch/">JSPatch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/New-Features/">New Features</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Native/">React Native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unowned/">unowned</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态化/">动态化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂/">杂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/签名/">签名</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/脚本/">脚本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/译文/">译文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/隐式解析可选类型/">隐式解析可选类型</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Bash/" style="font-size: 16.67px;">Bash</a> <a href="/tags/Books/" style="font-size: 20px;">Books</a> <a href="/tags/JSPatch/" style="font-size: 10px;">JSPatch</a> <a href="/tags/New-Features/" style="font-size: 10px;">New Features</a> <a href="/tags/React-Native/" style="font-size: 10px;">React Native</a> <a href="/tags/Swift/" style="font-size: 13.33px;">Swift</a> <a href="/tags/unowned/" style="font-size: 10px;">unowned</a> <a href="/tags/动态化/" style="font-size: 10px;">动态化</a> <a href="/tags/杂/" style="font-size: 13.33px;">杂</a> <a href="/tags/签名/" style="font-size: 10px;">签名</a> <a href="/tags/脚本/" style="font-size: 16.67px;">脚本</a> <a href="/tags/译文/" style="font-size: 10px;">译文</a> <a href="/tags/隐式解析可选类型/" style="font-size: 10px;">隐式解析可选类型</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/12/《1984》读书笔记/">《1984》读书笔记</a>
          </li>
        
          <li>
            <a href="/2019/01/03/2018年总结/">2018年总结</a>
          </li>
        
          <li>
            <a href="/2018/12/10/《Refactoring》读书笔记（四）重新组织数据/">《Refactoring》读书笔记（四）重新组织数据</a>
          </li>
        
          <li>
            <a href="/2018/12/04/《Refactoring》读书笔记（三）在对象之间搬移特性/">《Refactoring》读书笔记（三）在对象之间搬移特性</a>
          </li>
        
          <li>
            <a href="/2018/11/28/《Refactoring》读书笔记（二）重新组织函数/">《Refactoring》读书笔记（二）重新组织函数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 iCodeWoods<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>