<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css?v=1.0.2">















  
  
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">







<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-medium.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-small.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="iCodeWoods的小站">
<meta property="og:url" content="https://iCodeWoods.github.io/index.html">
<meta property="og:site_name" content="iCodeWoods的小站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iCodeWoods的小站">





  
  
  <link rel="canonical" href="https://iCodeWoods.github.io/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>iCodeWoods的小站</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">iCodeWoods的小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">片刻之欢愉，不如须臾之宁静</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iCodeWoods.github.io/2019/05/16/Runtime 温故而知新/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iCodeWoods">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iCodeWoods的小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/16/Runtime 温故而知新/" class="post-title-link" itemprop="url">Runtime 温故而知新</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-16 15:51:00" itemprop="dateCreated datePublished" datetime="2019-05-16T15:51:00+08:00">2019-05-16</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><p>本文基于 runtime 的最新版本 750，源码可以<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">点这里</a>下载，可编译版本可以<a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">点这里</a>下载。</p>
<h2 id="load"><a href="#load" class="headerlink" title="+ load"></a>+ load</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// main.m</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface XXObject : NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation XXObject</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">	NSLog(@&quot;XXObject load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过断点，我们可以看到如下调用栈：</p>
<p><img src="/2019/05/16/Runtime 温故而知新/Runtime_Breakpoint_Load.png" alt="Runtime_Breakpoint_Load"></p>
<h3 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">recursive_mutex_locker_t</span> lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">mutex_locker_t</span> lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码非常清晰：</p>
<ol>
<li><code>hasLoadMethods</code>：通过 <code>mach_header</code> 判断镜像中是否有 load 方法，如果没有直接返回</li>
<li><code>prepare_load_methods</code>：准备好 load 方法</li>
<li><code>call_load_methods</code>：调用 load 方法</li>
</ol>
<blockquote>
<p>PS：mach_header 是一个结构体，里面记录了镜像的一些信息。headerType 在非 64 位下就是 mach_header，在 64 位下是 mach_header_64</p>
</blockquote>
<p>那么 <code>load_images</code> 方法会加载哪些镜像呢？我们在 <code>hasLoadMethods</code> 处增加一个断点，输出 <code>path</code> 以及是否有 <code>load</code> 方法，截取其中一部分输出如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">load_images... path: <span class="string">"/usr/lib/system/introspection/libdispatch.dylib"</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">load_images... path: <span class="string">"/usr/lib/system/libsystem_trace.dylib"</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">load_images... path: <span class="string">"/usr/lib/system/libxpc.dylib"</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">load_images... path: <span class="string">"/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation"</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">load_images... path: <span class="string">"/System/Library/Frameworks/Security.framework/Versions/A/Security"</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">load_images... path: <span class="string">"/usr/lib/libnetwork.dylib"</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">load_images... path: <span class="string">"/System/Library/Frameworks/CFNetwork.framework/Versions/A/CFNetwork"</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// ...省略</span></span><br></pre></td></tr></table></figure>
<p>下面我们就来一步步分析 load_images 所干的这三件事。</p>
<blockquote>
<p>扩展阅读：Mach-O包含以下几种文件类型</p>
<ul>
<li>Executable：应用的主要二进制</li>
<li>Dylib：动态链接库</li>
<li>Bundle：不能被链接，只能在运行时使用dlopen加载</li>
<li>Image：包含 Executable、Dylib 和 Bundle</li>
<li>Framework：包含Dylib、资源文件和头文件的文件夹</li>
</ul>
</blockquote>
<h4 id="hasLoadMethods"><a href="#hasLoadMethods" class="headerlink" title="hasLoadMethods"></a>hasLoadMethods</h4><p>第一步，如何判断一个镜像中是否有 <code>load</code> 方法？其实就是查找该镜像中是否有“非懒加载的类”（NonlazyClass）或“非懒加载的分类”（NonlazyCategory）。结合这个方法的方法名，就很容易这两个概念了——有 <code>+ load</code> 方法的类/分类就是“非懒加载的”，没有 <code>+ load</code> 方法的类/分类就是懒加载的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm</span></span><br><span class="line"><span class="comment">// Quick scan for +load methods that doesn't take a lock.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasLoadMethods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyClassList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyCategoryList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="getObjc2NonlazyClassList"><a href="#getObjc2NonlazyClassList" class="headerlink" title="_getObjc2NonlazyClassList"></a>_getObjc2NonlazyClassList</h5><p>那么如何获取镜像中的 NonlazyClassList/NonlazyCategoryList 呢？我们跳转到 <code>_getObjc2NonlazyClassList</code> 的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object-file.mm</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETSECT(name, type, sectname)                                   \</span></span><br><span class="line">    <span class="function">type *<span class="title">name</span><span class="params">(<span class="keyword">const</span> headerType *mhdr, <span class="keyword">size_t</span> *outCount)</span> </span>&#123;              \</span><br><span class="line">        <span class="keyword">return</span> getDataSection&lt;type&gt;(mhdr, sectname, nil, outCount);     \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    <span class="function">type *<span class="title">name</span><span class="params">(<span class="keyword">const</span> header_info *hi, <span class="keyword">size_t</span> *outCount)</span> </span>&#123;               \</span><br><span class="line">        <span class="keyword">return</span> getDataSection&lt;type&gt;(hi-&gt;mhdr(), sectname, nil, outCount); \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//      function name                 content type     section name</span></span><br><span class="line">GETSECT(_getObjc2SelectorRefs,        SEL,             <span class="string">"__objc_selrefs"</span>); </span><br><span class="line">GETSECT(_getObjc2MessageRefs,         <span class="keyword">message_ref_t</span>,   <span class="string">"__objc_msgrefs"</span>); </span><br><span class="line">GETSECT(_getObjc2ClassRefs,           Class,           <span class="string">"__objc_classrefs"</span>);</span><br><span class="line">GETSECT(_getObjc2SuperRefs,           Class,           <span class="string">"__objc_superrefs"</span>);</span><br><span class="line">GETSECT(_getObjc2ClassList,           <span class="keyword">classref_t</span>,      <span class="string">"__objc_classlist"</span>);</span><br><span class="line">GETSECT(_getObjc2NonlazyClassList,    <span class="keyword">classref_t</span>,      <span class="string">"__objc_nlclslist"</span>);</span><br><span class="line">GETSECT(_getObjc2CategoryList,        <span class="keyword">category_t</span> *,    <span class="string">"__objc_catlist"</span>);</span><br><span class="line">GETSECT(_getObjc2NonlazyCategoryList, <span class="keyword">category_t</span> *,    <span class="string">"__objc_nlcatlist"</span>);</span><br><span class="line">GETSECT(_getObjc2ProtocolList,        <span class="keyword">protocol_t</span> *,    <span class="string">"__objc_protolist"</span>);</span><br><span class="line">GETSECT(_getObjc2ProtocolRefs,        <span class="keyword">protocol_t</span> *,    <span class="string">"__objc_protorefs"</span>);</span><br><span class="line">GETSECT(getLibobjcInitializers,       UnsignedInitializer, <span class="string">"__objc_init_func"</span>);</span><br></pre></td></tr></table></figure>
<p>乍一看有点懵，其实很简单，就是 🍎 工程师为了 <del>偷懒</del> 简洁，定义了一个宏来批量实现方法，好比一个模板。</p>
<p>举个🌰，对于 <code>_getObjc2NonlazyClassList</code> 来说，其实这里是实现了两个方法名一样，但参数不同的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">classref_t</span> *_getObjc2NonlazyClassList(<span class="keyword">const</span> headerType *mhdr, <span class="keyword">size_t</span> *outCount) &#123;</span><br><span class="line">    <span class="keyword">return</span> getDataSection&lt;<span class="keyword">classref_t</span>&gt;(mhdr, <span class="string">"__objc_nlclslist"</span>, nil, outCount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">classref_t</span> *_getObjc2NonlazyClassList(<span class="keyword">const</span> header_info *hi, <span class="keyword">size_t</span> *outCount) &#123;</span><br><span class="line">    <span class="keyword">return</span> getDataSection&lt;<span class="keyword">classref_t</span>&gt;(hi-&gt;mhdr, <span class="string">"__objc_nlclslist"</span>, nil, outCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 其实我第一眼看这段代码的时候，有一个疑问：为什么这里可以定义两个方法名一样、但参数不一样的方法呢？要知道在 OC 里，这样可是会报错的。过了一会我才突然想明白，这是 .mm 文件，C++ 是可以这样干的啊！差点被自己蠢哭😂</p>
</blockquote>
<h5 id="getDataSection"><a href="#getDataSection" class="headerlink" title="getDataSection"></a>getDataSection</h5><p>ok，现在只剩下 <code>getDataSection</code> 这个方法了：通过 headerType，获取镜像的指定 segment 的指定 section 中的数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object-file.mm</span></span><br><span class="line"><span class="comment">// Look for a __DATA or __DATA_CONST or __DATA_DIRTY section </span></span><br><span class="line"><span class="comment">// with the given name that stores an array of T.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T* <span class="title">getDataSection</span><span class="params">(<span class="keyword">const</span> headerType *mhdr, <span class="keyword">const</span> <span class="keyword">char</span> *sectname, </span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">size_t</span> *outBytes, <span class="keyword">size_t</span> *outCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> byteCount = <span class="number">0</span>;</span><br><span class="line">    T* data = (T*)getsectiondata(mhdr, <span class="string">"__DATA"</span>, sectname, &amp;byteCount);</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        data = (T*)getsectiondata(mhdr, <span class="string">"__DATA_CONST"</span>, sectname, &amp;byteCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        data = (T*)getsectiondata(mhdr, <span class="string">"__DATA_DIRTY"</span>, sectname, &amp;byteCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (outBytes) *outBytes = byteCount;</span><br><span class="line">    <span class="keyword">if</span> (outCount) *outCount = byteCount / <span class="keyword">sizeof</span>(T);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是以 <code>_getObjc2NonlazyClassList</code> 为🌰，会先查找 <code>__DATA</code> 段中的 <code>__objc_nlclslist</code> 区块，如果找不到再找 <code>__DATA_CONST</code> 段中的 <code>__objc_nlclslist</code> 区块，以此类推。如果都找不到的话，就说明这个镜像中没有 <code>NonlazyClass</code>，也就是没有 <code>+ load</code> 方法。</p>
<p>为了验证，我们可以在 demo 工程的 Products 目录下，找到工程的编译产物——一个可执行文件（debug-objc）</p>
<p><img src="/2019/05/16/Runtime 温故而知新/Runtime_Product_Exec.png" alt="Runtime_Product_Exec"></p>
<p>然后我们将其拖入 <a href="https://sourceforge.net/projects/machoview/" target="_blank" rel="noopener">MachOView</a> 中查看，在 <code>__DATA</code> 段的 <code>__objc_nlclslist</code> section 中确实只有一个元素，其地址为 <code>0000000100001138</code>（因为此处是大端序，我们将其转化为小端序）</p>
<p><img src="/2019/05/16/Runtime 温故而知新/Runtime_MachOView_NonLazyClass.png" alt="Runtime_MachOView_NonLazyClass"></p>
<p>然后我们将可执行文件拖入 <a href="https://www.hopperapp.com/" target="_blank" rel="noopener">Hopper</a>，找到 <code>0000000100001138</code> 地址上的数据，确实是我们所写的 <code>XXObject</code>：</p>
<p><img src="/2019/05/16/Runtime 温故而知新/Runtime_Hopper_XXObject.png" alt="Runtime_Hopper_XXObject"></p>
<h4 id="prepare-load-methods"><a href="#prepare-load-methods" class="headerlink" title="prepare_load_methods"></a>prepare_load_methods</h4><p>这个函数的作用就是提前将需要调用 <code>load</code> 方法的类和分类分别加入对应的列表中，以供接下来的调用（后面会详述）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">classref_t</span> *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">category_t</span> **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先看类的部分（为了方便快速理解大致逻辑、避免混乱，我们先暂时忽略 <code>remapClass</code>，后面会详述）。</p>
<h5 id="schedule-class-load"><a href="#schedule-class-load" class="headerlink" title="schedule_class_load"></a>schedule_class_load</h5><p><code>_getObjc2NonlazyClassList</code> 上文我们已经解释过了。获取当前镜像的所有非懒加载的类，然后进行遍历，调用 <code>schedule_class_load</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>通过 <code>RW_LOADED</code> 标志位判断类是否已经加载过，如果已经加载过则直接返回，保证<strong>每个类只会加载一次</strong></li>
<li>递归调用 <code>schedule_class_load</code> 对父类进行处理，保证<strong>父类在子类之前</strong>（这里只是”prepare”，不是调用，不过真正调用的时候父类也一定是在子类之前的，后面会详述）</li>
<li>将类和类的 load 方法保存至一个全局列表（<code>loadable_classes</code>）中</li>
<li>将类的 <code>RW_LOADED</code> 标志位置为 1</li>
</ol>
<p>#####add_class_to_loadable_list</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-loadmethod.mm</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"LOAD: class '%s' scheduled for +load"</span>, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            <span class="built_in">realloc</span>(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里通过 <code>loadable_classes_used</code> 记录其个数，<code>loadable_classes</code> 列表的大小是动态创建的，当列表长度不够用时会重新申请内存。（我想这就是为什么如果程序中 <code>+ load</code> 方法太多时，会影响启动性能的原因之一吧。当然影响因素很多，后面我们还会详述）</p>
<blockquote>
<p>上面的方法中，🍎 工程师还非常 <del>逗比</del> 有趣的加了一句注释：“如果类没有load方法，请不要打扰”。😂</p>
</blockquote>
<h5 id="add-category-to-loadable-list"><a href="#add-category-to-loadable-list" class="headerlink" title="add_category_to_loadable_list"></a>add_category_to_loadable_list</h5><p>分类的处理和类的处理差不多：将分类和分类的 load 方法保存至另一个全局列表 <code>loadable_categories</code> 中，通过 <code>loadable_categories_used</code> 记录其个数。我们就不再赘述了。</p>
<h5 id="remapClass"><a href="#remapClass" class="headerlink" title="remapClass"></a>remapClass</h5><p>上面我们说为了防止混乱而暂时忽略了一个方法 <code>remapClass</code>。其实通过 <code>_getObjc2NonlazyClassList</code> 获取的是 <code>classref_t</code>，通过注释我们可以看到它其实是一个“未映射”的 Class：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// classref_t is unremapped class_t*</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">classref</span> * <span class="title">classref_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>而 <code>remapClass</code> 的作用就是将 <code>classref_t</code> 进行重映射，拿到其所对应的 Class：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">remapClass</span><span class="params">(<span class="keyword">classref_t</span> cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remapClass((Class)cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">remapClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    Class c2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    NXMapTable *<span class="built_in">map</span> = remappedClasses(NO);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">map</span>  ||  NXMapMember(<span class="built_in">map</span>, cls, (<span class="keyword">void</span>**)&amp;c2) == NX_MAPNOTAKEY) &#123;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从镜像中获取到的未映射的 <code>classref_t</code> 与其所对应的真正的 Class 是作为一对 key-value 存储在一个映射表里的，其中 <code>classref_t</code> 是 key，对应的 Class 是 value。</p>
<p>不过看到这我们还是不知道，这个映射表是哪来的？后面我们会详述。</p>
<p>下面我们就进入第三步：<code>call_load_methods</code></p>
<h4 id="call-load-methods"><a href="#call-load-methods" class="headerlink" title="call_load_methods"></a>call_load_methods</h4><p>do while 中会先调用 <code>call_class_loads</code>，再调用 call_category_loads，这就保证了<strong>类的 <code>+ load</code> 会在分类之前调用</strong>。（还记得 <code>loadable_classes_used</code> 吗，我们上文提过哦。）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>网上有些博客说，我们重载 <code>+ load</code> 方法时需要手动添加 @autoreleasepool，甚至包括<a href="https://www.mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.html" target="_blank" rel="noopener">Mike Ash 的博客</a>也是这么说的。</p>
<p>但从这段源码我们可以看到，在 <code>runtime</code> 调用<code>+ load</code> 方法的前后已经加了 <code>objc_autoreleasePoolPush()</code> 和 <code>objc_autoreleasePoolPop()</code>，所以我们不需要再手动添加了。大抵是因为他们所写的博客太老了，之后🍎做了更新吧。</p>
<h5 id="call-class-loads"><a href="#call-class-loads" class="headerlink" title="call_class_loads"></a>call_class_loads</h5><p><code>call_class_loads</code> 就是将我们上文所说的 <code>loadable_classes</code> 列表中的类一个一个拿出来，然后调用其 <code>+ load</code> 方法。因为之前写入 <code>loadable_classes</code> 列表时，是先写入的父类，后写入的子类，所以这里<strong>父类的 load 会先于子类调用</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> *<span class="title">classes</span> = <span class="title">loadable_classes</span>;</span></span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) <span class="built_in">free</span>(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心在于这一句，通过函数指针的方式执行 <code>classes[i].method</code>——也就是 <code>+ load</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*load_method)(cls, SEL_load);</span><br></pre></td></tr></table></figure>
<p>这样的调用方式就使得 <code>+ load</code> 有了一个非常有趣的特性。我们知道，通常情况下我们给一个对象发送消息，其实是调用了 <code>objc_msgSend</code> 方法，如果对象不能响应消息，会递归地查找其父类/元类并调用。</p>
<p>而此处 <code>+ load</code> 方法直接使用了函数地址进行调用，并不是通过 <code>objc_msgSend</code>，所以<strong>如果子类没有实现 <code>+ load</code> 方法，那么 runtime 不会调用父类的 <code>+ load</code>。如果类和分类都实现了 <code>+ load</code> 方法，两个方法都会被调用</strong>。</p>
<p>到这里 <code>load_images</code> 的整个流程就讲完了，不过如果你跟我一样好奇的话，查看 <code>SEL_load</code> 时会发现——它竟然是个 <code>NULL</code>！！！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// objc-runtime.mm</span><br><span class="line">// Selectors</span><br><span class="line">SEL SEL_load = NULL;</span><br><span class="line">SEL SEL_initialize = NULL;</span><br><span class="line">SEL SEL_resolveInstanceMethod = NULL;</span><br><span class="line">SEL SEL_resolveClassMethod = NULL;</span><br><span class="line">SEL SEL_cxx_construct = NULL;</span><br><span class="line">SEL SEL_cxx_destruct = NULL;</span><br><span class="line">SEL SEL_retain = NULL;</span><br><span class="line">SEL SEL_release = NULL;</span><br><span class="line">SEL SEL_autorelease = NULL;</span><br><span class="line">SEL SEL_retainCount = NULL;</span><br><span class="line">SEL SEL_alloc = NULL;</span><br><span class="line">SEL SEL_allocWithZone = NULL;</span><br><span class="line">SEL SEL_dealloc = NULL;</span><br><span class="line">SEL SEL_copy = NULL;</span><br><span class="line">SEL SEL_new = NULL;</span><br><span class="line">SEL SEL_forwardInvocation = NULL;</span><br><span class="line">SEL SEL_tryRetain = NULL;</span><br><span class="line">SEL SEL_isDeallocating = NULL;</span><br><span class="line">SEL SEL_retainWeakReference = NULL;</span><br><span class="line">SEL SEL_allowsWeakReference = NULL;</span><br></pre></td></tr></table></figure>
<p>至于为什么会这样，我们后面会详述。</p>
<h4 id="Producer-Consumer"><a href="#Producer-Consumer" class="headerlink" title="Producer-Consumer"></a>Producer-Consumer</h4><p>细心的读者可能已经发现了，<code>load_images</code> 里其实蕴含着一个经典的生产者-消费者问题：</p>
<ul>
<li><code>prepare_load_methods</code> 负责“生产”：从镜像中获取实现了 <code>+ load</code> 方法的类/分类，将类/分类及其 load 方法写入 <code>loadable_classes</code>/<code>loadable_categories</code> 列表中；</li>
<li><code>call_load_methods</code> 负责“消费”：循环地从 <code>loadable_classes</code>/<code>loadable_categories</code> 列表中读取类/分类，执行其 <code>+ load</code> 方法</li>
</ul>
<h5 id="loadMethodLock"><a href="#loadMethodLock" class="headerlink" title="loadMethodLock"></a>loadMethodLock</h5><p>当然，🍎 已经加好了锁。因为类和分类的流程大同小异，所以我们以类为🌰：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `prepare_load_methods` 负责“生产”</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `call_load_methods` 负责“消费”</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    call_class_loads</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> *<span class="title">classes</span> = <span class="title">loadable_classes</span>;</span></span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    (*load_method)(cls, SEL_load);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (classes) <span class="built_in">free</span>(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="objc-init"><a href="#objc-init" class="headerlink" title="_objc_init"></a>_objc_init</h2><p>还记得我们之前遗留的问题吗？remapClass 中的那个映射表是哪来的？<code>SEL_load</code> 等选择子为什么是 NULL？</p>
<p>之所以会遇到这些问题，其实是因为我们前面有些“急于求成”，从 <code>load</code> 方法处的断点定位到 <code>load_images</code> 后就直接一头扎了进去，而没有想想——<code>load_images</code> 是谁调用的？在 <code>load_images</code> 之前发生了什么？</p>
<p>我们在 <code>load_images</code> 处添加一个断点，通过调用栈可以看到另一个方法：<code>_objc_init</code></p>
<p><img src="/2019/05/16/Runtime 温故而知新/Runtime_Breakpoint_LoadImages.png" alt="Runtime_Breakpoint_LoadImages"></p>
<p>其源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-os.mm</span></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _objc_init</span></span><br><span class="line"><span class="comment">* Bootstrap initialization. Registers our image notifier with dyld.</span></span><br><span class="line"><span class="comment">* Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里做了很多初始化的工作，并通过一个静态的布尔型变量保证该方法只会走一次。我们的关注点在于最后一行，这里出现了我们前面花了大量篇幅所讲的 <code>load_images</code>，那么这一整行代码是什么意思呢？</p>
<h3 id="dyld-objc-notify-register"><a href="#dyld-objc-notify-register" class="headerlink" title="_dyld_objc_notify_register"></a>_dyld_objc_notify_register</h3><p>我们跳转到 <code>_dyld_objc_notify_register</code> 的定义，这里已经踏入 dyld 的领地了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dyld_priv.h</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*_dyld_objc_notify_mapped)</span><span class="params">(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> paths[], <span class="keyword">const</span> struct mach_header* <span class="keyword">const</span> mh[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*_dyld_objc_notify_init)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> struct mach_header* mh)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*_dyld_objc_notify_unmapped)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> struct mach_header* mh)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note: only for use by objc runtime</span></span><br><span class="line"><span class="comment">// Register handlers to be called when objc images are mapped, unmapped, and initialized.</span></span><br><span class="line"><span class="comment">// Dyld will call back the "mapped" function with an array of images that contain an objc-image-info section.</span></span><br><span class="line"><span class="comment">// Those images that are dylibs will have the ref-counts automatically bumped, so objc will no longer need to</span></span><br><span class="line"><span class="comment">// call dlopen() on them to keep them from being unloaded.  During the call to _dyld_objc_notify_register(),</span></span><br><span class="line"><span class="comment">// dyld will call the "mapped" function with already loaded objc images.  During any later dlopen() call,</span></span><br><span class="line"><span class="comment">// dyld will also call the "mapped" function.  Dyld will call the "init" function when dyld would be called</span></span><br><span class="line"><span class="comment">// initializers in that image.  This is when objc calls any +load methods in that image.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped);</span><br></pre></td></tr></table></figure>
<p>请允许我蹩脚的翻译一下其中的部分内容：</p>
<blockquote>
<p>“注册处理程序，以便 oc 的镜像在被 mapped、unmappped 和 initialized 时调用……当 dyld 初始化一个镜像时，会调用 init 函数，镜像的 + load 方法就在这个函数中被调用。”</p>
</blockquote>
<p>（这里的 “init function”，也就是我们上文所说的 <code>load_images</code>）</p>
<p>所以 runtime 其实是注册了三个监听：<code>_dyld_objc_notify_mapped</code> 、 <code>_dyld_objc_notify_init</code> 、 <code>_dyld_objc_notify_unmapped</code>，对应着三个不同的回调。当一个镜像被 mapped、init 和 unmapped 时，dyld 就会通知 runtime 进行相应的处理。</p>
<p> 那么显然，想要解答我们之前遗留的困惑，就需要去看看在 “init” 之前的 “mapped” 中都做了些什么。</p>
<h3 id="map-images"><a href="#map-images" class="headerlink" title="map_images"></a>map_images</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//objc-runtime-new.mm</span></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* map_images</span></span><br><span class="line"><span class="comment">* Process the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">* Calls ABI-agnostic code after taking ABI-specific locks.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">map_images(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span><br><span class="line">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mutex_locker_t</span> lock(runtimeLock);</span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="map-images-nolock"><a href="#map-images-nolock" class="headerlink" title="map_images_nolock"></a>map_images_nolock</h4><p><code>map_images_nolock</code> 的实现比较长，我们忽略掉一些相对不那么重要的内容，然后挑选其中一部分讲讲：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-os.mm</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">map_images_nolock(<span class="keyword">unsigned</span> mhCount, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> mhPaths[],</span><br><span class="line">                  <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> firstTime = YES;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">        sel_init(selrefCount);</span><br><span class="line">        arr_init();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    firstTime = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，当第一次执行时，这里会做一些初始化的操作，下面我们就分别来看一下 <code>sel_init</code> 、 <code>arr_init</code> 、 <code>_read_images</code> 这三步都做了些什么。</p>
<h5 id="sel-init"><a href="#sel-init" class="headerlink" title="sel_init"></a>sel_init</h5><p>顾名思义，这里就是初始化 SEL 的地方，我们前面的问题 <code>SEL SEL_load = NULL;</code> 也将在这里得到解答。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-sel.mm</span></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* sel_init</span></span><br><span class="line"><span class="comment">* Initialize selector tables and register selectors used internally.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sel_init</span><span class="params">(<span class="keyword">size_t</span> selrefCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ...略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register selectors used by libobjc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s(x) SEL_##x = sel_registerNameNoLock(#x, NO)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> t(x,y) SEL_##y = sel_registerNameNoLock(#x, NO)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutex_locker_t</span> lock(selLock);</span><br><span class="line"></span><br><span class="line">    s(load);</span><br><span class="line">    s(initialize);</span><br><span class="line">    t(resolveInstanceMethod:, resolveInstanceMethod);</span><br><span class="line">    t(resolveClassMethod:, resolveClassMethod);</span><br><span class="line">    t(.cxx_construct, cxx_construct);</span><br><span class="line">    t(.cxx_destruct, cxx_destruct);</span><br><span class="line">    s(retain);</span><br><span class="line">    s(release);</span><br><span class="line">    s(autorelease);</span><br><span class="line">    s(retainCount);</span><br><span class="line">    s(alloc);</span><br><span class="line">    t(allocWithZone:, allocWithZone);</span><br><span class="line">    s(dealloc);</span><br><span class="line">    s(copy);</span><br><span class="line">    s(<span class="keyword">new</span>);</span><br><span class="line">    t(forwardInvocation:, forwardInvocation);</span><br><span class="line">    t(_tryRetain, tryRetain);</span><br><span class="line">    t(_isDeallocating, isDeallocating);</span><br><span class="line">    s(retainWeakReference);</span><br><span class="line">    s(allowsWeakReference);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> s</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似地，这里也 <del>偷懒</del> 巧妙的使用了宏定义来起到模板的作用。我们以 <code>load</code> 为🌰，<code>s(load);</code> 相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SEL_load = sel_registerNameNoLock(&quot;load&quot;, NO);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>##</code> 是拼接，<code>#</code> 是转化为字符串</p>
</blockquote>
<p>最终调用的是 <code>__sel_registerName</code>，这里会去一个全局的映射表中进行查找，如果表不存在则创建一个，如果在表中没有找到，则将 SEL name 和 SEL 作为一对 key-value 添加到映射表中。至此我们关于 SEL 的问题便得到了答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-sel.mm</span></span><br><span class="line"><span class="keyword">static</span> SEL __sel_registerName(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> shouldLock, <span class="keyword">bool</span> copy) </span><br><span class="line">&#123;</span><br><span class="line">    SEL result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...略</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (namedSelectors) &#123;</span><br><span class="line">        result = (SEL)NXMapGet(namedSelectors, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!namedSelectors) &#123;</span><br><span class="line">        namedSelectors = NXCreateMapTable(NXStrValueMapPrototype, </span><br><span class="line">                                          (<span class="keyword">unsigned</span>)SelrefCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        result = sel_alloc(name, copy);</span><br><span class="line">        NXMapInsert(namedSelectors, sel_getName(result), result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="arr-init"><a href="#arr-init" class="headerlink" title="arr_init"></a>arr_init</h5><p>回到 <code>map_images_nolock</code> 中，我们继续看另一个初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arr_init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage::init();</span><br><span class="line">    SideTableInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来 <code>AutoreleasePool</code> 和 <code>SideTable</code> 都是在这里初始化的。有的同学可能对 <code>SideTable</code> 比较陌生，大名鼎鼎的引用计数表以及 <code>weak</code> 的实现原理等，全都和它有关。关于 <code>AutoreleasePool</code> 和 <code>SideTable</code>，我们会在其它文章中单独介绍。</p>
<h5 id="read-images"><a href="#read-images" class="headerlink" title="_read_images"></a>_read_images</h5><p>现在 <code>map_images_nolock</code> 中只剩下一个重头戏：<code>_read_images</code> 了。这个方法的实现长得令人发指（400行），<del>笔者已经无力吐槽</del>，主要是检查所有的 header_into，处理其中的 类、分类、协议、消息等信息，插入相应的映射表中。我们摘取其中比较重要的部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-runtime-new.mm</span></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _read_images</span></span><br><span class="line"><span class="comment">* Perform initial processing of the headers in the linked </span></span><br><span class="line"><span class="comment">* list beginning with headerList. </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Called by: map_images_nolock</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock acquired by map_images</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, <span class="keyword">uint32_t</span> hCount, <span class="keyword">int</span> totalClasses, <span class="keyword">int</span> unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    <span class="function">TimeLogger <span class="title">ts</span><span class="params">(PrintImageTimes)</span></span>;</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    NXCreateHashTable</span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: first time tasks"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    _getObjc2ClassList</span><br><span class="line">    readClass</span><br><span class="line">	ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: discover classes"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    _getObjc2ClassRefs</span><br><span class="line">    remapClassRef</span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: remap classes"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    _getObjc2SelectorRefs</span><br><span class="line">    sel_registerNameNoLock</span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: fix up selector references"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    _getObjc2MessageRefs</span><br><span class="line">    fixupMessageRef</span><br><span class="line">	ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: fix up objc_msgSend_fixup"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    _getObjc2ProtocolList</span><br><span class="line">    readProtocol</span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: discover protocols"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    _getObjc2ProtocolRefs</span><br><span class="line">    remapProtocolRef</span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: fix up @protocol references"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    _getObjc2NonlazyClassList</span><br><span class="line">    realizeClass</span><br><span class="line">	ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: realize non-lazy classes"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    _getObjc2CategoryList</span><br><span class="line">    addUnattachedCategoryForClass</span><br><span class="line">    remethodizeClass</span><br><span class="line">	ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: discover categories"</span>);</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面每一处都是一次对所有 header_info 的遍历（但其实我不太明白在一次遍历中做这些事不行么？）</p>
<p>这里🍎已经写好了各个步骤耗时的监测，我们看上面的第一行代码：<code>TimeLogger ts(PrintImageTimes);</code> ，我们跳转到 <code>PrintImageTimes</code> 的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// objc-env.h</span><br><span class="line">// OPTION(var, env, help)</span><br><span class="line"></span><br><span class="line">OPTION( PrintImages,              OBJC_PRINT_IMAGES,               &quot;log image and library names as they are loaded&quot;)</span><br><span class="line">OPTION( PrintImageTimes,          OBJC_PRINT_IMAGE_TIMES,          &quot;measure duration of image loading steps&quot;)</span><br><span class="line">OPTION( PrintLoading,             OBJC_PRINT_LOAD_METHODS,         &quot;log calls to class and category +load methods&quot;)</span><br><span class="line">OPTION( PrintInitializing,        OBJC_PRINT_INITIALIZE_METHODS,   &quot;log calls to class +initialize methods&quot;)</span><br><span class="line">OPTION( PrintResolving,           OBJC_PRINT_RESOLVED_METHODS,     &quot;log methods created by +resolveClassMethod: and +resolveInstanceMethod:&quot;)</span><br><span class="line">OPTION( PrintConnecting,          OBJC_PRINT_CLASS_SETUP,          &quot;log progress of class and category setup&quot;)</span><br><span class="line">OPTION( PrintProtocols,           OBJC_PRINT_PROTOCOL_SETUP,       &quot;log progress of protocol setup&quot;)</span><br><span class="line">OPTION( PrintIvars,               OBJC_PRINT_IVAR_SETUP,           &quot;log processing of non-fragile ivars&quot;)</span><br><span class="line">OPTION( PrintVtables,             OBJC_PRINT_VTABLE_SETUP,         &quot;log processing of class vtables&quot;)</span><br><span class="line">OPTION( PrintVtableImages,        OBJC_PRINT_VTABLE_IMAGES,        &quot;print vtable images showing overridden methods&quot;)</span><br><span class="line">OPTION( PrintCaches,              OBJC_PRINT_CACHE_SETUP,          &quot;log processing of method caches&quot;)</span><br><span class="line">OPTION( PrintFuture,              OBJC_PRINT_FUTURE_CLASSES,       &quot;log use of future classes for toll-free bridging&quot;)</span><br><span class="line">OPTION( PrintPreopt,              OBJC_PRINT_PREOPTIMIZATION,      &quot;log preoptimization courtesy of dyld shared cache&quot;)</span><br><span class="line">OPTION( PrintCxxCtors,            OBJC_PRINT_CXX_CTORS,            &quot;log calls to C++ ctors and dtors for instance variables&quot;)</span><br><span class="line">OPTION( PrintExceptions,          OBJC_PRINT_EXCEPTIONS,           &quot;log exception handling&quot;)</span><br><span class="line">OPTION( PrintExceptionThrow,      OBJC_PRINT_EXCEPTION_THROW,      &quot;log backtrace of every objc_exception_throw()&quot;)</span><br><span class="line">OPTION( PrintAltHandlers,         OBJC_PRINT_ALT_HANDLERS,         &quot;log processing of exception alt handlers&quot;)</span><br><span class="line">OPTION( PrintReplacedMethods,     OBJC_PRINT_REPLACED_METHODS,     &quot;log methods replaced by category implementations&quot;)</span><br><span class="line">OPTION( PrintDeprecation,         OBJC_PRINT_DEPRECATION_WARNINGS, &quot;warn about calls to deprecated runtime functions&quot;)</span><br><span class="line">OPTION( PrintPoolHiwat,           OBJC_PRINT_POOL_HIGHWATER,       &quot;log high-water marks for autorelease pools&quot;)</span><br><span class="line">OPTION( PrintCustomRR,            OBJC_PRINT_CUSTOM_RR,            &quot;log classes with un-optimized custom retain/release methods&quot;)</span><br><span class="line">OPTION( PrintCustomAWZ,           OBJC_PRINT_CUSTOM_AWZ,           &quot;log classes with un-optimized custom allocWithZone methods&quot;)</span><br><span class="line">OPTION( PrintRawIsa,              OBJC_PRINT_RAW_ISA,              &quot;log classes that require raw pointer isa fields&quot;)</span><br><span class="line"></span><br><span class="line">OPTION( DebugUnload,              OBJC_DEBUG_UNLOAD,               &quot;warn about poorly-behaving bundles when unloaded&quot;)</span><br><span class="line">OPTION( DebugFragileSuperclasses, OBJC_DEBUG_FRAGILE_SUPERCLASSES, &quot;warn about subclasses that may have been broken by subsequent changes to superclasses&quot;)</span><br><span class="line">OPTION( DebugNilSync,             OBJC_DEBUG_NIL_SYNC,             &quot;warn about @synchronized(nil), which does no synchronization&quot;)</span><br><span class="line">OPTION( DebugNonFragileIvars,     OBJC_DEBUG_NONFRAGILE_IVARS,     &quot;capriciously rearrange non-fragile ivars&quot;)</span><br><span class="line">OPTION( DebugAltHandlers,         OBJC_DEBUG_ALT_HANDLERS,         &quot;record more info about bad alt handler use&quot;)</span><br><span class="line">OPTION( DebugMissingPools,        OBJC_DEBUG_MISSING_POOLS,        &quot;warn about autorelease with no pool in place, which may be a leak&quot;)</span><br><span class="line">OPTION( DebugPoolAllocation,      OBJC_DEBUG_POOL_ALLOCATION,      &quot;halt when autorelease pools are popped out of order, and allow heap debuggers to track autorelease pools&quot;)</span><br><span class="line">OPTION( DebugDuplicateClasses,    OBJC_DEBUG_DUPLICATE_CLASSES,    &quot;halt when multiple classes with the same name are present&quot;)</span><br><span class="line">OPTION( DebugDontCrash,           OBJC_DEBUG_DONT_CRASH,           &quot;halt the process by exiting instead of crashing&quot;)</span><br><span class="line"></span><br><span class="line">OPTION( DisableVtables,           OBJC_DISABLE_VTABLES,            &quot;disable vtable dispatch&quot;)</span><br><span class="line">OPTION( DisablePreopt,            OBJC_DISABLE_PREOPTIMIZATION,    &quot;disable preoptimization courtesy of dyld shared cache&quot;)</span><br><span class="line">OPTION( DisableTaggedPointers,    OBJC_DISABLE_TAGGED_POINTERS,    &quot;disable tagged pointer optimization of NSNumber et al.&quot;) </span><br><span class="line">OPTION( DisableTaggedPointerObfuscation, OBJC_DISABLE_TAG_OBFUSCATION,    &quot;disable obfuscation of tagged pointers&quot;)</span><br><span class="line">OPTION( DisableNonpointerIsa,     OBJC_DISABLE_NONPOINTER_ISA,     &quot;disable non-pointer isa fields&quot;)</span><br><span class="line">OPTION( DisableInitializeForkSafety, OBJC_DISABLE_INITIALIZE_FORK_SAFETY, &quot;disable safety checks for +initialize after fork&quot;)</span><br></pre></td></tr></table></figure>
<p>(<em>@ο@</em>) 哇～偌大的一个宝库！这里定义了大量的运行时环境变量，如果开启的话，不仅有助于我们学习 runtime 的源码，也大大方便了负责性能优化的同学做一些统计的耗时等。</p>
<p>我们就以刚刚说到的 <code>PrintImageTimes</code> 为例，它对应的运行时环境变量为 <code>OBJC_PRINT_IMAGE_TIMES</code> ，我们在 Xcode -&gt; Project -&gt; Scheme -&gt; Edit Scheme 中将该环境变量设为 YES：</p>
<p><img src="/2019/05/16/Runtime 温故而知新/Runtime_PrintOption_PrintImageTimes.png" alt="Runtime_PrintOption_PrintImageTimes"></p>
<p>运行程序，就可以方便地看到各阶段的耗时了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">objc[<span class="number">40242</span>]: <span class="number">0.39</span> ms: IMAGE TIMES: first time tasks</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">18.40</span> ms: IMAGE TIMES: discover classes</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">0.00</span> ms: IMAGE TIMES: remap classes</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">100.89</span> ms: IMAGE TIMES: fix up selector references</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">0.14</span> ms: IMAGE TIMES: fix up objc_msgSend_fixup</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">2.47</span> ms: IMAGE TIMES: discover protocols</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">0.67</span> ms: IMAGE TIMES: fix up @protocol references</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">3.50</span> ms: IMAGE TIMES: realize non-lazy classes</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">0.00</span> ms: IMAGE TIMES: realize future classes</span><br><span class="line">objc[<span class="number">40242</span>]: <span class="number">3.00</span> ms: IMAGE TIMES: discover categories</span><br><span class="line"><span class="number">2019</span><span class="number">-04</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">02.921120</span>+<span class="number">0800</span> debug-objc[<span class="number">40242</span>:<span class="number">2106148</span>] Hello, World!</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/16/Runtime 温故而知新/Runtime_Process.png" alt="runtime_process"></p>
<h2 id="initialize"><a href="#initialize" class="headerlink" title="+ initialize"></a>+ initialize</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// ViewController.m</span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface SubViewController : ViewController</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubViewController</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;SubViewController initialize...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;ViewController initialize...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    SubViewController *subVC = [[SubViewController alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    </span><br><span class="line">2019-05-15 16:55:02.331135+0800 Test[25870:1727530] ViewController initialize...</span><br><span class="line">2019-05-15 16:55:02.334713+0800 Test[25870:1727530] SubViewController initialize...</span><br></pre></td></tr></table></figure>
<p>那么如果我们把子类中的 <code>+ initialize</code> 删掉，会是什么样呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// ViewController.m</span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface SubViewController : ViewController</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubViewController</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;ViewController initialize... self = %@&quot;, self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    SubViewController *subVC = [[SubViewController alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    </span><br><span class="line">2019-05-15 16:55:50.386359+0800 Test[25907:1728843] ViewController initialize... self = ViewController</span><br><span class="line">2019-05-15 16:55:50.390092+0800 Test[25907:1728843] ViewController initialize... self = SubViewController</span><br></pre></td></tr></table></figure>
<p>查看源码，可以发现 <code>initialize</code> 的调用是通过 <code>objc_msgSend</code>，所以如果子类没有实现，则会调用父类的方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callInitialize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说如果我们不加判断的话，一个类的 initialize 可能会执行多次，而这并不一定是我们想要的。</p>
<p>Q：那么有的同学可能会说，如果我们没有子类，或者子类实现了 <code>+ initialize</code> 不就没问题了么？</p>
<p>A：❌。我们来看下面这个🌰，现在我们让子类实现 <code>+ initialize</code>，这样子类就不会再调用父类的 <code>+initialize</code>了。然后我们给父类添加一个 KVO，猜猜现在输出是什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// ViewController.m</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface SubViewController : ViewController</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubViewController</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;SubViewController initialize...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong) SubViewController *subVC;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;ViewController initialize... self = %@&quot;, self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.subVC = [[SubViewController alloc] init];</span><br><span class="line">    </span><br><span class="line">    [self addObserver:self forKeyPath:@&quot;view&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self removeObserver:self forKeyPath:@&quot;view&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    </span><br><span class="line">2019-05-15 16:52:14.792672+0800 Test[25830:1725181] ViewController initialize... self = ViewController</span><br><span class="line">2019-05-15 16:52:14.796562+0800 Test[25830:1725181] SubViewController initialize...</span><br><span class="line">2019-05-15 16:52:14.796983+0800 Test[25830:1725181] ViewController initialize... self = NSKVONotifying_ViewController</span><br></pre></td></tr></table></figure>
<p><code>ViewController</code> 的 <code>+ initialize</code> 还是被调用了两次。这是因为 KVO 动态地创建了一个子类（<code>NSKVONotifying_ViewController</code>），而这个子类不会重写 <code>+ initialize</code>，所以父类的 <code>+ initialize</code> 就又被调用了。</p>
<p>那么我们该如何解决呢？🍎 的文档中说：“If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (void)initialize &#123;</span><br><span class="line">    if (self == [ClassName self]) &#123;</span><br><span class="line">        // ... do the initialization ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p>Q：如果一个类实现了 <code>+ load</code> 方法，但是这个类没有被使用（import），那么它还会在 load_images 时加载嘛？<br>A：会。</p>
<p>Q：如果一个类实现了 <code>+ load</code> 方法，但是具体实现内容是空，那么还会在 load_images 时被加载嘛？<br>A：会。</p>
<p>Q：同一个镜像中，多个不同的类、多个不同的分类的 <code>+ load</code> 调用顺序是怎样的？<br>A：编译顺序。</p>
<p>Q：同一个镜像中，NonLazyClassA 依赖了 NonLazyClassB，那么它们的 <code>+ load</code> 调用顺序是怎样的？<br>A：还是编译顺序。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/objc4/</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2016/406" target="_blank" rel="noopener">https://developer.apple.com/videos/play/wwdc2016/406</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048</a></li>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.html" target="_blank" rel="noopener">https://www.mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.html</a></li>
<li><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc" target="_blank" rel="noopener">http://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc</a></li>
<li><a href="https://nshipster.com/method-swizzling/" target="_blank" rel="noopener">https://nshipster.com/method-swizzling/</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iCodeWoods.github.io/2019/04/02/SpriteKit 开发游戏实战——《OverTheMountains》/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iCodeWoods">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iCodeWoods的小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/02/SpriteKit 开发游戏实战——《OverTheMountains》/" class="post-title-link" itemprop="url">SpriteKit 开发游戏实战——《OverTheMountains》</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-02 18:20:35" itemprop="dateCreated datePublished" datetime="2019-04-02T18:20:35+08:00">2019-04-02</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>SpriteKit 早在 iOS 7 就已推出，但由于我的精力/水平有限，直到最近才开始学习它。</p>
<p>文章中的游戏《OverTheMountains》（翻山越岭）是我从零开始自学 SpriteKit 时，用了不到三天时间自己开发的一个小型 demo，并没有参考别人的代码，所以可能存在很多不合理的地方，还望各位不吝赐教，我将非常感激。</p>
<p>项目工程的 <a href="https://github.com/iCodeWoods/OverTheMountains" target="_blank" rel="noopener">GitHub 地址请戳我</a>。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/04/02/SpriteKit 开发游戏实战——《OverTheMountains》/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iCodeWoods.github.io/2019/03/12/《1984》读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iCodeWoods">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iCodeWoods的小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/12/《1984》读书笔记/" class="post-title-link" itemprop="url">《1984》读书笔记</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-12 13:42:40" itemprop="dateCreated datePublished" datetime="2019-03-12T13:42:40+08:00">2019-03-12</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>战争就是和平</p>
<p>自由就是奴役</p>
<p>无知就是力量</p>
</blockquote>
<p>开卷就看到如此荒诞不已的文字，而接下来的故事也果然没有辜负这份荒诞。。。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/03/12/《1984》读书笔记/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iCodeWoods.github.io/2019/01/03/2018年总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iCodeWoods">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iCodeWoods的小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/03/2018年总结/" class="post-title-link" itemprop="url">2018年总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-03 13:34:52" itemprop="dateCreated datePublished" datetime="2019-01-03T13:34:52+08:00">2019-01-03</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/杂/" itemprop="url" rel="index"><span itemprop="name">杂</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><p>8102 年是我来到网易的第三年、来到 NB iOS Team 的第二年。</p>
<p>这一年我的输入不少，但输出不多；</p>
<p>这一年我犯的错误不少，但做的总结/反思不多；</p>
<p>总体而言，尽管有不足之处，但感觉无论是自己还是整个团队，这一年的进步都很大。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/01/03/2018年总结/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iCodeWoods.github.io/2018/12/10/《Refactoring》读书笔记（四）重新组织数据/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iCodeWoods">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iCodeWoods的小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/10/《Refactoring》读书笔记（四）重新组织数据/" class="post-title-link" itemprop="url">《Refactoring》读书笔记（四）重新组织数据</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-10 13:37:18" itemprop="dateCreated datePublished" datetime="2018-12-10T13:37:18+08:00">2018-12-10</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="第八章-重新组织数据"><a href="#第八章-重新组织数据" class="headerlink" title="第八章 重新组织数据"></a>第八章 重新组织数据</h1><h2 id="8-1-Self-Encapsulate-Field（自封装字段）"><a href="#8-1-Self-Encapsulate-Field（自封装字段）" class="headerlink" title="8.1 Self Encapsulate Field（自封装字段）"></a>8.1 Self Encapsulate Field（自封装字段）</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。</p>
<p><strong>为这个字段建立取值/设值函数，并且只以这些函数来访问字段。</strong></p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/12/10/《Refactoring》读书笔记（四）重新组织数据/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iCodeWoods.github.io/2018/12/04/《Refactoring》读书笔记（三）在对象之间搬移特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iCodeWoods">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iCodeWoods的小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/04/《Refactoring》读书笔记（三）在对象之间搬移特性/" class="post-title-link" itemprop="url">《Refactoring》读书笔记（三）在对象之间搬移特性</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-04 13:39:35" itemprop="dateCreated datePublished" datetime="2018-12-04T13:39:35+08:00">2018-12-04</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="第七章-在对象之间搬移特性"><a href="#第七章-在对象之间搬移特性" class="headerlink" title="第七章 在对象之间搬移特性"></a>第七章 在对象之间搬移特性</h1><h2 id="7-1-Move-Method（搬移函数）"><a href="#7-1-Move-Method（搬移函数）" class="headerlink" title="7.1 Move Method（搬移函数）"></a>7.1 Move Method（搬移函数）</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或者被后者调用。</p>
<p><strong>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。</strong></p>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>“搬移函数”是重构理论的支柱。通过这种手段，可以使系统中的类更简单，这些类最终也将更干净利落地实现系统交付的任务。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/12/04/《Refactoring》读书笔记（三）在对象之间搬移特性/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iCodeWoods.github.io/2018/11/28/《Refactoring》读书笔记（二）重新组织函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iCodeWoods">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iCodeWoods的小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/11/28/《Refactoring》读书笔记（二）重新组织函数/" class="post-title-link" itemprop="url">《Refactoring》读书笔记（二）重新组织函数</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-28 13:34:38" itemprop="dateCreated datePublished" datetime="2018-11-28T13:34:38+08:00">2018-11-28</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="第六章-重新组织函数"><a href="#第六章-重新组织函数" class="headerlink" title="第六章 重新组织函数"></a>第六章 重新组织函数</h1><h2 id="6-1-Extract-Method（提炼函数）"><a href="#6-1-Extract-Method（提炼函数）" class="headerlink" title="6.1 Extract Method（提炼函数）"></a>6.1 Extract Method（提炼函数）</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>你有一段代码可以被组织在一起并独立出来。</p>
<p><strong>将这段代码放进一个独立函数中，并让函数名称解释该函数的用途。</strong></p>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>复用机会大，覆写更容易，使高层函数读起来就像一系列注释。</p>
<p>函数长度不是问题，关键在于函数名称和函数本体之间的语义距离。如果提炼可以强化代码的清晰度，那就去做，就算函数名称比提炼出来的代码还长也无所谓。</p>
<p>难点在于局部变量，包括传进源函数的参数和源函数所声明的临时变量。</p>
<p>可以先尝试运用 Replace Temp with Query（120）减少临时变量。如果仍困难重重，我就会动用 Replace Method with Method Object（135），这个重构手法不在乎代码中有多少临时变量，也不在乎你如何使用它们。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/11/28/《Refactoring》读书笔记（二）重新组织函数/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iCodeWoods.github.io/2018/11/21/《Refactoring》读书笔记（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iCodeWoods">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iCodeWoods的小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/11/21/《Refactoring》读书笔记（一）/" class="post-title-link" itemprop="url">《Refactoring》读书笔记（一）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-21 13:20:26" itemprop="dateCreated datePublished" datetime="2018-11-21T13:20:26+08:00">2018-11-21</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="第一章-重构，第一个案例"><a href="#第一章-重构，第一个案例" class="headerlink" title="第一章 重构，第一个案例"></a>第一章 重构，第一个案例</h1><blockquote>
<p>如果你发现自己需要为程序添加一个特效，而代码结构使你无法很方便地达成目的，那就先重构那个程序，使特性的添加比较容易进行，然后再添加特性。</p>
</blockquote>
<blockquote>
<p>重构前，先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验能力。</p>
</blockquote>
<blockquote>
<p>任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。</p>
</blockquote>
<p><strong>重构时最好小步前进，如此一来犯错的几率最小。</strong></p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/11/21/《Refactoring》读书笔记（一）/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iCodeWoods.github.io/2018/10/30/《浪潮之巅》读书笔记（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iCodeWoods">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iCodeWoods的小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/30/《浪潮之巅》读书笔记（二）/" class="post-title-link" itemprop="url">《浪潮之巅》读书笔记（二）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-30 17:59:20" itemprop="dateCreated datePublished" datetime="2018-10-30T17:59:20+08:00">2018-10-30</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="第四章-计算机工业的生态链"><a href="#第四章-计算机工业的生态链" class="headerlink" title="第四章 计算机工业的生态链"></a>第四章 计算机工业的生态链</h1><h2 id="计算机行业的发展规律"><a href="#计算机行业的发展规律" class="headerlink" title="计算机行业的发展规律"></a>计算机行业的发展规律</h2><ul>
<li>摩尔定律</li>
<li>安迪•比尔定律</li>
<li>反摩尔定律</li>
</ul>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/10/30/《浪潮之巅》读书笔记（二）/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iCodeWoods.github.io/2018/10/15/《浪潮之巅》读书笔记（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="iCodeWoods">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iCodeWoods的小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/10/15/《浪潮之巅》读书笔记（一）/" class="post-title-link" itemprop="url">《浪潮之巅》读书笔记（一）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-15 11:31:24" itemprop="dateCreated datePublished" datetime="2018-10-15T11:31:24+08:00">2018-10-15</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="第二章-蓝色巨人-IBM公司"><a href="#第二章-蓝色巨人-IBM公司" class="headerlink" title="第二章 蓝色巨人 IBM公司"></a>第二章 蓝色巨人 IBM公司</h1><ul>
<li>当今工业界最大的实验室</li>
<li>世界第一的专利申请大户</li>
<li>全球最大的RISC服务器制造商</li>
</ul>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/10/15/《浪潮之巅》读书笔记（一）/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">iCodeWoods</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/iCodeWoods" title="GitHub &rarr; https://github.com/iCodeWoods" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">iCodeWoods</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>



  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
